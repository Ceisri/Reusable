extends KinematicBody
#player rotation, animation and otherwise mostly visual stuff
onready var player_mesh = get_node("Mesh")
onready var an = $Mesh/AnimationPlayer
var blend = 0.25
var is_in_combat = false
var dual_wield_mode = false
var bow_mode = false
var two_handed_sword_mode = false
var one_handed_sword_mode = false
var sword_and_shield_mode = false
var crossbow_mode = false
var magic_staff_mode = false
var barehanded_mode = true
var can_move = true 
#collision booleans 
var has_ride = false 
# movement variables
var velocity := Vector3()
export var gravity = 9.8
const base_sprint_speed = 10
export var sprint_speed = 10
var teleport_distance = 35
var attack_move_speed = 4.5
export (float) var mouse_sense = 0.1
# Dodge
export var double_press_time: float = 0.4
var dash_countback: int = 0
var dash_timerback: float = 0.0
# Dodge Left
var dash_countleft: int = 0
var dash_timerleft: float = 0.0
# Dodge right
var dash_countright: int = 0
var dash_timerright: float = 0.0
# Dodge forward
var dash_countforward: int = 0
var dash_timerforward: float = 0.0
# Dodge multidirection (not in strafe mode)
var dash_count1 : int = 0
var dash_timer1 : float = 0.0
var dash_count2 : int = 0
var dash_timer2 : float = 0.0
# Condition States
var enabled_climbing = true
var is_riding = bool()
var is_falling = bool()
var is_swimming =bool()
var is_rolling = bool()
var is_walking = false
var was_walking = false
var is_running = bool()
var is_sprinting = bool()
var is_aiming = bool()
var is_cursor = false
var is_crouching = bool()
var attacking = bool()
var is_sliding = false
var is_guarding = false
var is_climbing = false
var mousemode = bool()
var staggered = false
var blocking = false
var backstep = bool()
var frontstep = bool()
var leftstep = bool()
var rightstep =bool()
var stunned = false
var injured = false
# Physics values
var direction = Vector3()
var horizontal_velocity = Vector3()
var aim_turn = float()
var movement = Vector3()
var vertical_velocity = Vector3()
var movement_speed = int()
var angular_acceleration = int()
var acceleration = int()
#preloads and loads  for UI
#onready var tool_tip = load("res://player/UI/HoverText/Test.tscn")
#other UI stuff 
#onready var all_ui = $AllUIHere
#onready var warden_skill_ui = $AllUIHere/Skills/WardenSkills
#onready var debugger = $AllUIHere/Debugger
#Save data
const SAVE_DIR = "user://saves/"
var save_path = SAVE_DIR + "save.dat"

#___________________________________Class Specific____________________________________________
#set1
var has_headstrong_rush_skill = false

#invested points 
var headstrong_rush_ps = 0
var pomel_strike_ps = 0
var cross_parry_ps = 0
var measured_slice_ps = 0 
var blood_rush_ps = 0
#headstrong rush skill 
#onready var HeadstrongrushCD = $AllUIHere/Skills/WardenSkills/Set1/HeadstrongRush/HeadstrongrushCD
var headstrong_duration = 5
var headstrong_rush_toggle = false
#set3
var has_pomel_strike_skill = true
var has_entagle_skill = false 
var has_disarm_skill = false
var has_expose_skill = false
var has_cripple_skill = false 
#set4
var has_wallop_skill = false
var has_rising_strike_skill = false
var has_schadenfreude_skill = false
var has_eviscerate_skill = false 
var has_punishing_blow_skill = false 
#set5
var has_shield_bash_counter_skill = false
var has_lunge_skill = false 
var has_provocation_skill = false 
var has_shield_barrage_skill = false #move and attack while covered behind the shield at the same time 
var has_shield_counter_skill= false #after blocking a hit, bash enemy with the shield and trust
var rng = RandomNumberGenerator.new()
func _on_FakeOnready_timeout():#for some reason _ready() doesn't work, maybe too much data to load
	updateHeightLabel()
	switchHair()
	colorhair()
	colorEyeL()
	colorEyeR()
	switchFaces()

func _ready():
	loadPlayerData()
	mouse = true
	set_process_input(true)	
	direction = Vector3.BACK.rotated(Vector3.UP,  camera_h.global_transform.basis.get_euler().y)
	Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
func _input(event):
	if event is InputEventKey:
		if event.scancode == KEY_P:  # Replace with the desired key code
			resetSavedData()
	if event is InputEventMouseMotion:
		camrot_h += -event.relative.x * h_sensitivity
		camrot_v += event.relative.y * v_sensitivity
		if minimap_rotate:
			minimap_camera.rotate_y(deg2rad(-event.relative.x * mouse_sense))
	#Scrollwheel zoom in and out 		
	if event is InputEventMouseButton and event.button_index == BUTTON_WHEEL_UP:
		# Zoom in when scrolling up
		Zoom(-1)
	elif event is InputEventMouseButton and event.button_index == BUTTON_WHEEL_DOWN:
		# Zoom out when scrolling down
		Zoom(1)
func _physics_process(delta):
#	if is_network_master():
		if not stunned:
				jump()
				dodgeBack(delta)
				dodgeFront(delta)
				dodgeLeft(delta)
				dodgeRight(delta)	
				move()
				movementStates()
				climbing()
				teleport()
				minimapFollow()
				MainWeapon()
				SecWeapon()
				pauldronsManagement()
				ShieldManagement()
				switchWeaponStances()
				enterCombat()
				earingManagement()
				bagManagement()
				showEnemyStats()
		mouseMode()		
		stiffCamera(delta)	
		ridingCollision()
		Gravity(delta)
		interpol(delta)
		gliding()
		animationsAll(delta)
		cameraRotation(delta)
		unstuckDisplayCD()
		unstuckVisibility()
		unstuckDisplayCD()
		money()
		UpadateHealthLabelsAndSomeAttributes()
		levelUP()
		if health > max_health:
			health = max_health
		if mouse:
			Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)
		else:
			Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
func _on_5FPS_timeout():
	shoot()
	updateAllAttributeLabels()
	updateExperienceAndLevelLabel()
	updateAttributePointsLabel()
	updateExpMult()
	UpdateAllStats()
	updateHeightLabel()
	manageEnergy()
#__________________________________________Movement_________________________________
func move():
	var h_rot =  camera_h.global_transform.basis.get_euler().y
	movement_speed = 0
	angular_acceleration = 3.25
	acceleration = 15
	movement.z = horizontal_velocity.z + vertical_velocity.z
	movement.x = horizontal_velocity.x + vertical_velocity.x
	movement.y = vertical_velocity.y
	move_and_slide(movement, Vector3.UP)
	if not is_climbing:
		if Input.is_action_pressed("forward") or Input.is_action_pressed("backward") or Input.is_action_pressed("left") or Input.is_action_pressed("right"):
			direction = Vector3(Input.get_action_strength("left") - Input.get_action_strength("right"),
						0,
						Input.get_action_strength("forward") - Input.get_action_strength("backward"))
			direction = direction.rotated(Vector3.UP, h_rot).normalized()
			is_walking = true
		else: 
			is_walking = false
func movementStates():
	if is_walking:	
			# Movement States
		if Input.is_action_pressed("run") and is_walking and not is_climbing and not blocking and not is_swimming and not is_aiming:
					movement_speed = run_speed * agility
					is_in_combat = false
					is_running = true
					enabled_climbing = false
					is_crouching = false
					is_aiming = false
		elif Input.is_action_pressed("C") and is_walking and !is_climbing and !is_swimming:
				movement_speed = crouch_speed
				is_running = false
				enabled_climbing = false
				is_crouching = true
				is_aiming = false
				is_in_combat = false
		elif Input.is_action_pressed("sprint") and is_walking and not is_climbing and not blocking and not is_swimming and not is_aiming:
					movement_speed = sprint_speed * agility
					is_sprinting = true
					enabled_climbing = false
					is_crouching = false
					is_aiming = false
					is_in_combat = false
		else:  # Walk State and speed
				movement_speed = walk_speed
				is_sprinting = false
				is_crouching = false
				enabled_climbing = true
				is_crouching = false
				is_running = false
	else:  # Walk State and speed
			is_sprinting = false
			is_crouching = false
			enabled_climbing = true
			is_crouching = false
			is_running = false
func dodgeBack(delta):#Doddge when in strafe mode
		if dash_countback > 0:
			dash_timerback += delta
		if dash_timerback >= double_press_time:
			dash_countback = 0
			dash_timerback = 0.0
		if Input.is_action_just_pressed("backward"):
			dash_countback += 1
		if dash_countback == 2 and dash_timerback < double_press_time:
			horizontal_velocity = direction * dash_power
			backstep = true
			enabled_climbing = false
		else:
			enabled_climbing = true
			backstep = false
func dodgeFront(delta):#Dodge when in strafe mode
		if dash_countforward > 0:
			dash_timerforward += delta
		if dash_timerforward >= double_press_time:
			dash_countforward = 0
			dash_timerforward = 0.0
		if Input.is_action_just_pressed("forward"):
			dash_countforward += 1
		if dash_countforward == 2 and dash_timerforward < double_press_time:
			horizontal_velocity = direction * dash_power *1.5
			frontstep = true
			enabled_climbing = false
		else:
			enabled_climbing = true
			frontstep = false
func dodgeLeft(delta):#Dodge when in strafe mode
		if dash_countleft > 0:
			dash_timerleft += delta
		if dash_timerleft >= double_press_time:
			dash_countleft = 0
			dash_timerleft = 0.0
		if Input.is_action_just_pressed("left"):
			dash_countleft += 1
		if dash_countleft == 2 and dash_timerleft < double_press_time:
			horizontal_velocity = direction * dash_power
			enabled_climbing = false
			leftstep = true
		else:
			enabled_climbing = true
			leftstep = false
func dodgeRight(delta):#Dodge when in strafe mode
		if dash_countright > 0:
			dash_timerright += delta
		if dash_timerright >= double_press_time:
			dash_countright = 0
			dash_timerright = 0.0
		if Input.is_action_just_pressed("right"):
			dash_countright += 1
		if dash_countright == 2 and dash_timerright < double_press_time :
			horizontal_velocity = direction * dash_power
			enabled_climbing = false
			rightstep = true
		else:
			enabled_climbing = true
			rightstep = false
func teleport():
	if Input.is_action_just_pressed("X"):
		var teleport_vector = direction.normalized() * teleport_distance
		var teleport_position = translation + teleport_vector
		var collision = move_and_collide(teleport_vector)
		if collision:
			teleport_position = collision.position
			translation = teleport_position
#climbing section
var wall_incline
var is_wall_in_range = false
onready var head_ray = $Mesh/HeadRay
onready var climb_ray = $Mesh/ClimbRay
func climbing():
	if not is_swimming and strength > 0.99:
		if climb_ray.is_colliding() and is_on_wall():
			if Input.is_action_pressed("forward"):
					checkWallInclination()
					is_climbing = true
					is_swimming = false
					if not head_ray.is_colliding() and not is_wall_in_range:#vaulting
						an.play("climb top",blend, strength * 0.4)#vaulting animation placeholder
						vertical_velocity = Vector3.UP * (strength * 0.6 + (agility * 0.15))
						horizontal_velocity = direction * 15
					elif not is_wall_in_range:#normal climb
						an.play("climb cycle",blend, strength)
						vertical_velocity = Vector3.UP * (strength * 0.65 + (agility * 0.15))
					else:
						vertical_velocity = Vector3.UP * (strength * 1.25 + (agility * 0.15))
						horizontal_velocity = direction * walk_speed
						if strength < 2:
							an.play("crawl incline cycle", blend)
						else:
							an.play("walk cycle", blend)
			else:
				is_climbing = false
		else:
			is_climbing = false
func checkWallInclination():
	if get_slide_count() > 0:
		var collision_info = get_slide_collision(0)
		var normal = collision_info.normal
		if normal.length_squared() > 0:
			wall_incline = acos(normal.y)  # Calculate the inclination angle in radians
			wall_incline = rad2deg(wall_incline)  # Convert inclination angle to degrees
			if normal.x < 0:
				wall_incline = -wall_incline
			# Check if the wall inclination is within the specified range 
			is_wall_in_range = (wall_incline >= -60 and wall_incline <= 60)
		else:
			wall_incline = 0  # Set to 0 if the normal is not valid
			is_wall_in_range = false
	else:
		wall_incline = 0  # Set to 0 if there is no collision
		is_wall_in_range = false
func jump():
	if Input.is_action_pressed("jump") and is_on_floor():
		vertical_velocity = Vector3.UP *  jumping_power
	if Input.is_action_pressed("jump") and is_swimming:
		vertical_velocity = Vector3.UP * 2.5
	elif Input.is_action_pressed("C") and is_swimming:
		vertical_velocity = Vector3.DOWN * 2.5
func gliding():
	if is_falling:
		if Input.is_action_pressed("Z"):
			vertical_velocity = direction * 1 
			horizontal_velocity = direction * 20 * agility 
			vertical_velocity = Vector3.ZERO  # No vertical movement while gliding
			movement_speed =  walk_speed
			an.play("Tpose")
			is_in_combat = false 
func interpol(delta):
	horizontal_velocity = horizontal_velocity.linear_interpolate(direction.normalized() * movement_speed, acceleration * delta)
func Gravity(delta):# Gravity and stop sliding on floors
	if not is_climbing:
		if not is_on_floor() and not is_swimming:
			vertical_velocity += Vector3.DOWN * 60 * delta
			is_falling = true
		else:
			vertical_velocity = -get_floor_normal() * gravity / 2.5 
			is_falling = false
#_____________________________________________Camera________________________________________________
var camrot_h = 0
var camrot_v = 0
onready var parent = $".."
export var cam_v_max = 200 # -75 recommended
export var cam_v_min = -125 # -55 recommended
onready var camera_v =$Camroot/h/v
onready var camera_h =$Camroot/h
onready var camera = $Camroot/h/v/Camera
onready var minimap = $Minimap
onready var minimap_camera = $Minimap/Viewport/Camera
var minimap_rotate = false
var h_sensitivity = 0.1
var v_sensitivity = 0.1
var rot_speed_multiplier = .15 #reduce this to make the rotation radius larger
var h_acceleration = 10
var v_acceleration = 10
var touch_start_position = Vector2.ZERO
var zoom_speed = 0.1
# Add this function to handle zooming logic
func Zoom(zoom_direction):
	# Adjust the camera's position based on the zoom direction
	camera.translation.y += zoom_direction * zoom_speed
	camera.translation.z -= zoom_direction * zoom_speed
func _on_Sensitivity_pressed():
	$Minimap/sensitivity_label.text = "cam sens: " + str(h_sensitivity)
	h_sensitivity += 0.025
func _on_SensitivityMin_pressed():
	h_sensitivity -= 0.025
	$Minimap/sensitivity_label.text = "cam sens: " + str(h_sensitivity)
func cameraRotation(delta):
	if not is_cursor:
		camrot_v = clamp(camrot_v, cam_v_min, cam_v_max)
		#MOUSE CAMERA
		camera_h.rotation_degrees.y = lerp(camera_h.rotation_degrees.y, camrot_h, delta * h_acceleration)
		camera_v.rotation_degrees.x = lerp(camera_v.rotation_degrees.x, camrot_v, delta * v_acceleration)
var mouse = false
func mouseMode():
	if Input.is_action_pressed("rclick"):
		is_aiming = true
	else:
		is_aiming = false	
	if Input.is_action_just_pressed("mousemode") or Input.is_action_just_pressed("ui_cancel"):	# Toggle mouse mode
		is_in_combat = false
		is_cursor =!is_cursor
		mouse =!mouse
func stiffCamera(delta):
		if is_aiming:
			player_mesh.rotation.y = lerp_angle(player_mesh.rotation.y, camera_h.rotation.y, delta * angular_acceleration)
		else:
			player_mesh.rotation.y = lerp_angle(player_mesh.rotation.y, atan2(direction.x, direction.z) - rotation.y, delta * angular_acceleration)	
func minimapFollow():# Update the position of the minimap camera
	minimap_camera.translation = Vector3(translation.x, 30,translation.z)
#_______________________________________Collisions__________________________________
func ridingCollision():
	if has_ride or dash_countforward >0 or dash_countback >0 or dash_countleft >0 or dash_countright >0:
		# If has_horse is true, change collision layers
		set_collision_layer(6)  # Set to the desired collision layer
		set_collision_mask(6)   # Set to the desired collision mask
	elif not has_ride:
		# If has_horse is false, reset collision layers
		set_collision_layer(1)  # Set to the original collision layer
		set_collision_mask(1)   # Set to the original collision mask
#__________________________________Animation Section_____________________________________
func animationsAll(delta):
	if is_in_combat:
		if barehanded_mode:
			animationsBarehanded()	
		elif one_handed_sword_mode:
			animations1HSword(delta)	
		elif two_handed_sword_mode:
			animations2HSword()
		elif dual_wield_mode:
			animationsDualWield(delta)
		elif bow_mode:
			animationsBow()	
		elif sword_and_shield_mode:
			animationsSwordAndShield(delta)	
	else:
		if not is_swimming:
			if is_aiming:
				animationStrafe()
			else:
				animationOutOfCombat()	
	if is_swimming:
		if is_walking:
			an.play("swim cycle",blend)
		else:
			an.play("idle water",blend)
	if not is_on_floor() and not is_climbing and not is_swimming:
		an.play("Tpose",blend)
#____________________________________Sword and Shield Animations_______________________________________
func animationsSwordAndShield(delta):
	if Input.is_action_pressed("rclick"): #block
		if  dash_countforward ==2:
			an.play("slide",blend)
		elif  dash_countleft ==2:
			an.play_backwards("dodge right",blend)
		elif  dash_countright ==2:
			an.play("dodge right",blend)
		elif  dash_countback ==2:
			an.play_backwards("backstep",blend)
		elif Input.is_action_pressed("attack") and has_pomel_strike_skill:
			an.play("pomel strike",blend)#placeholder counter attack
			horizontal_velocity = Vector3.ZERO
		elif Input.is_action_pressed("forward") and Input.is_action_pressed("left"):
			an.play("block shield front left",blend)
		elif Input.is_action_pressed("backward") and Input.is_action_pressed("left"):
			an.play_backwards("block shield front right",blend)
		elif Input.is_action_pressed("backward") and Input.is_action_pressed("right"):
			an.play_backwards("block shield front left",blend)
		elif Input.is_action_pressed("forward") and Input.is_action_pressed("right"):
			an.play("block shield front right", blend)
		elif Input.is_action_pressed("backward"):
			an.play_backwards("block shield front ",blend)
		elif Input.is_action_pressed("left"):
			an.play("shield block left",blend)
		elif Input.is_action_pressed("right"):
			an.play("shield block right ",blend)
		elif Input.is_action_pressed("forward"):
			an.play("block shield front ",blend)
		else:
			an.play("block shield",blend/2)	
	else:
		if dash_countback ==2 or dash_countleft ==2 or dash_countright ==2 or dash_countforward ==2:
			an.play("slide",blend)

		elif Input.is_action_pressed("E"):
			an.play("fury strike cycle", blend +0.1)
			moveAttack2(delta)
		elif Input.is_action_pressed("attack"):
			an.play("combo attack sword and shield cycle")
			moveAttack(delta)
		elif is_sliding and attacking:
			an.play("swirl melee attack",blend)
		elif is_walking:
			an.play("walk combat",blend)		
		else:
			an.play("idle combat",blend)
#_________________________________________One handed Sword animations_____________________________________________
func animations1HSword(delta):
	if Input.is_action_pressed("attack"):
		an.play("combo attack 1h cycle",0,1.5)
		#moveAttack(delta)
	elif is_walking:
		if not injured:
			an.play("walk cycle")
		else:
			an.play("walk injured")
	elif is_crouching:
		if is_running:
			an.play("sneak run")
		elif is_walking:
			an.play("sneak walk")
		else:
			an.play("sneak")
	else:
		an.play("1h idle")
#_____________________________________________Two handed Sword_____________________________________
func animations2HSword():
	if Input.is_action_pressed("attack"):
		an.play("combo attack 2h")
	elif is_walking:
		if not injured:
			an.play("walk")
		else:
			an.play("walk injured")
	elif is_crouching:
		if is_running:
			an.play("sneak run")
		elif is_walking:
			an.play("sneak walk")
		else:
			an.play("sneak")
	else:
		an.play("idle combat 2h", blend)
#_____________________________________________Dual Wielding______________________________________________
func animationsDualWield(delta):
	if not is_climbing:
		if Input.is_action_pressed("attack"):
			an.play("combo attack 2w", blend, melee_atk_speed)
			#moveAttack2(delta)
		elif is_walking:
			if not injured:
				an.play("walk cycle")
			else:
				an.play("walk injured")
		elif is_crouching:
			if is_running:
				an.play("sneak run")
			elif is_walking:
				an.play("sneak walk")
			else:
				an.play("sneak")
		else:
			an.play("2w idle ", blend)
#__________________________________________Bow______________________________________
func animationsBow():
	if Input.is_action_pressed("attack") and is_walking and not is_aiming:
		an.play("shoot forward", blend)
	elif Input.is_action_pressed("attack") and is_aiming and Input.is_action_pressed("left"):
		an.play("shoot left", blend)
	elif Input.is_action_pressed("attack") and is_aiming and Input.is_action_pressed("right"):
		an.play("shoot right", blend)
	elif Input.is_action_pressed("attack") and is_aiming and Input.is_action_pressed("left"):
		an.play("shoot back", blend)
	elif Input.is_action_pressed("attack") and is_walking :
		an.play("shoot forward", blend)
	elif Input.is_action_pressed("attack"):
		an.play("shoot arrow", blend)
	elif is_walking:
		if not injured:
			an.play("walk")
		else:
			an.play("walk injured")
	elif is_crouching:
		if is_running:
			an.play("sneak run")
		elif is_walking:
			an.play("sneak walk")
		else:
			an.play("sneak")
	else:
		an.play("idle combat", blend)
#___________________________________________Empty Handed_____________________________________________
func animationsBarehanded():
	if Input.is_action_pressed("attack"):
		if has_axe2:
			an.play("Chop cycle",blend, strength* 0.75)
		else:
			an.play("kick")
	elif is_walking:
		if not injured:
			an.play("walk")
		else:
			an.play("walk injured")
	elif is_crouching:
		if is_running:
			an.play("sneak run")
		elif is_walking:
			an.play("sneak walk")
		else:
			an.play("sneak")
	elif Input.is_action_just_pressed("jump"):
		an.play_backwards("terrified")
	else:
		an.play("idle combat")
#____________________________________________Out of Combat_________________________________
func animationOutOfCombat(): #normal
	#dodge section is prioritized
	if dash_countback ==2 or dash_countleft ==2 or dash_countright ==2 or dash_countforward ==2 or is_sliding:
		an.play("slide",blend)
#out of combat normal movement
	elif !is_in_combat and !is_swimming and is_on_floor() and !is_aiming:
		if is_sprinting:
			an.play("run cycle",blend, 0.9 *agility)
		elif is_running:
			an.play("run cycle", blend,0.8* agility)
		elif is_walking and Input.is_action_pressed("C"):
			an.play("sneak walk")
		elif is_running and Input.is_action_pressed("C"):
			an.play("sneak run")
		elif is_walking:
			an.play("walk cycle")
			is_chopping_trees = false
		elif Input.is_action_pressed("C"):
			an.play("sneak",blend)
		elif has_axe2 and  Input.is_action_pressed("attack"):
				an.play("chop cycle",blend *2 , strength*0.75)
				is_chopping_trees = true 
			
		elif Input.is_action_just_pressed("Q"):
			an.play_backwards("terrified")			
		else:
			an.play("idle")
			is_chopping_trees = false
func animationStrafe(): #strafe
	#dodge section is prioritized
		if dash_countback ==2:
			an.play("backstep",blend)
		elif dash_countleft ==2:
			an.play("TPose",blend)
		elif dash_countright ==2:
			an.play("TPose",blend)
		elif dash_countforward ==2:
			an.play_backwards("backstep",blend)
	#strafing walk 
		elif Input.is_action_pressed("forward") and Input.is_action_pressed("left"):
			an.play("left front",blend)
		elif Input.is_action_pressed("backward") and Input.is_action_pressed("left"):
			an.play_backwards("right front",blend)
		elif Input.is_action_pressed("backward") and Input.is_action_pressed("right"):
			an.play_backwards("left front",blend)
		elif Input.is_action_pressed("forward") and Input.is_action_pressed("right"):
			an.play("right front", blend)
		elif Input.is_action_pressed("backward"):
			an.play_backwards("walk",blend)
		elif Input.is_action_pressed("left"):
			an.play("left",blend)
		elif Input.is_action_pressed("right"):
			an.play("right",blend)
		elif Input.is_action_pressed("forward"):
			an.play("walk cycle")
		elif Input.is_action_just_pressed("jump"):
			an.play_backwards("landing")
		else:
			an.play("idle cycle",blend)
#________________________________________Graphic User Interface____________________________________
onready var debugger = $"../RichTextLabel"
onready var coordinates = $Minimap/Coordinates
func debugText():
	debugger.text = "Memory: %.3f MB" % (OS.get_static_memory_usage() / (1024.0 * 1024.0))
func roundPositionCoordinates():
	var rounded_position = Vector3(
		round(global_transform.origin.x * 10) / 10,
		round(global_transform.origin.y * 10) / 10,
		round(global_transform.origin.z * 10) / 10
	)
	# Use %d to format integers without decimals
	coordinates.text = "%d, %d, %d" % [rounded_position.x, rounded_position.y, rounded_position.z]
onready var time_label = $Minimap/Time
func displayClock():
	# Get the current date and time
	var datetime = OS.get_datetime()
	# Display hour and minute in the label
	time_label.text = "Time: %02d:%02d" % [datetime.hour, datetime.minute]	
#________________________________________Crude Stats________________________________________________
onready var health_label = $HealthLabel
onready var energy_label = $EnergyLabel
onready var resolve_label = $ResolveLabel
func UpadateHealthLabelsAndSomeAttributes():
	var health_text = "Health: %.2f / %.2f" % [health, max_health]
	health_label.text = health_text
	energy_label.text = "Energy: %.2f / %.2f" % [energy, max_energy]
	resolve_label.text = "Resolve %.2f / %.2f" % [resolve, max_resolve]
	resistanceMath()


#______________________________________Attributes UI________________________________________________
var entity_name = "Cei"
var health = 100
const base_health = 100
var max_health = 100
const base_max_health = 100
var energy = 100
var max_energy = 100
const base_max_energy = 100
var resolve = 100
var max_resolve = 100
const base_max_resolve = 100
var defense =  10
const base_defense = 0
#psuedo physics
const base_weight = 60
var weight = 60
const base_walk_speed = 6
var walk_speed = 3
const base_run_speed = 7
var run_speed = 7
const base_crouch_speed = 2
var crouch_speed = 2
const base_jumping_power = 20
var jumping_power = 20
const base_dash_power = 10
var dash_power = 10
#leveling
var skill_points = 0
var sanity  = 1
var wisdom = 1
var memory = 1
var intelligence = 1
var instinct = 1
var force = 1
var strength = 1
var impact = 1
var ferocity  = 1 
var fury = 1 
#precision atts
var accuracy = 1
var dexterity = 1
var poise = 1
var balance = 1
var focus = 1
#nimbleness atts
var haste = 1
var agility = 1
var celerity = 1
var flexibility = 1
var deflection = 1
#thoughness atts
var endurance = 1
var stamina = 1
var vitality = 1
var resistance = 1
var tenacity = 1
#social atts
const base_charisma = 1 
var charisma = 1
var charisma_multiplier = 1 
var loyalty = 1 
var diplomacy = 1
var authority = 1
var empathy = 1
var courage = 1 
var recovery = 1
#Leveling compounding attributes 
var spent_attribute_points_san = 0
var spent_attribute_points_wis = 0
var spent_attribute_points_mem = 0
var spent_attribute_points_int = 0
var spent_attribute_points_ins = 0

var spent_attribute_points_for = 0
var spent_attribute_points_str = 0
var spent_attribute_points_fur = 0
var spent_attribute_points_imp = 0
var spent_attribute_points_fer = 0

var spent_attribute_points_foc = 0
var spent_attribute_points_bal = 0
var spent_attribute_points_dex = 0
var spent_attribute_points_acc = 0
var spent_attribute_points_poi = 0

var spent_attribute_points_has = 0
var spent_attribute_points_agi = 0
var spent_attribute_points_cel = 0
var spent_attribute_points_fle = 0
var spent_attribute_points_def = 0

var spent_attribute_points_end = 0
var spent_attribute_points_sta = 0
var spent_attribute_points_vit = 0
var spent_attribute_points_res = 0
var spent_attribute_points_ten = 0

var spent_attribute_points_cha = 0
var spent_attribute_points_loy = 0 
var spent_attribute_points_dip = 0
var spent_attribute_points_aut = 0
var spent_attribute_points_cou = 0

onready var stats_label = $BookStatsSkills/Stats
onready var stats_and_skills = $BookStatsSkills
onready var int_value = $BookStatsSkills/StatsBrains/IntVal
onready var ins_value = $BookStatsSkills/StatsBrains/InsVal
onready var wis_value = $BookStatsSkills/StatsBrains/WisVal
onready var mem_value = $BookStatsSkills/StatsBrains/MemVal
onready var san_value = $BookStatsSkills/StatsBrains/SanVal
onready var str_value = $BookStatsSkills/StatsBrawns/StrVal
onready var for_value = $BookStatsSkills/StatsBrawns/ForVal
onready var imp_value = $BookStatsSkills/StatsBrawns/ImpVal
onready var fer_value = $BookStatsSkills/StatsBrawns/FerVal
onready var fur_value = $BookStatsSkills/StatsBrawns/FurVal
onready var vit_value = $BookStatsSkills/StatsToughness/VitVal
onready var sta_value = $BookStatsSkills/StatsToughness/StaVal
onready var end_value = $BookStatsSkills/StatsToughness/EndVal
onready var res_value = $BookStatsSkills/StatsToughness/ResVal
onready var ten_value = $BookStatsSkills/StatsToughness/TenVal
onready var dex_value = $BookStatsSkills/StatsPrecision/DexVal
onready var acc_value = $BookStatsSkills/StatsPrecision/AccVal
onready var foc_value = $BookStatsSkills/StatsPrecision/FocVal
onready var poi_value = $BookStatsSkills/StatsPrecision/PoiVal
onready var bal_value = $BookStatsSkills/StatsPrecision/BalVal
onready var cha_value = $BookStatsSkills/StatsSocial/ChaVal
onready var dip_value = $BookStatsSkills/StatsSocial/DipVal
onready var aut_value = $BookStatsSkills/StatsSocial/AutVal
onready var cou_value = $BookStatsSkills/StatsSocial/CouVal
onready var loy_value = $BookStatsSkills/StatsSocial/LoyVal
onready var agi_value = $BookStatsSkills/StatsNimble/AgiVal
onready var has_value = $BookStatsSkills/StatsNimble/HasVal
onready var cel_value = $BookStatsSkills/StatsNimble/CelVal
onready var fle_value = $BookStatsSkills/StatsNimble/FleVal
onready var def_value = $BookStatsSkills/StatsNimble/DefVal
onready var att_points_label = $BookStatsSkills/AttPoints
onready var critical_chance_val = $BookStatsSkills/CombatStats/GridContainer/CritChanceValue
onready var critical_str_val = $BookStatsSkills/CombatStats/GridContainer/CritDamage
onready var life_steal_value = $BookStatsSkills/CombatStats/GridContainer/LifeStealValue
func updateExperienceAndLevelLabel():
	exp_level_label.text = "experience points : " + str(experience)+ "  " + "Level :" + str(level)
func updateAttributePointsLabel():
	if stats_and_skills.visible:
		att_points_label.text = str(attribute)
onready var exp_level_label = $BookStatsSkills/ExpLevel
func updateAllAttributeLabels():
	if stats_and_skills.visible:
		int_value.text = "%.3f" % intelligence
		ins_value.text = "%.3f" % instinct
		wis_value.text = "%.3f" % wisdom
		vit_value.text = "%.3f" % vitality
		res_value.text = "%.3f" % resistance
		mem_value.text = "%.3f" % memory
		san_value.text = "%.3f" % sanity
		str_value.text = "%.3f" % strength
		for_value.text = "%.3f" % force
		imp_value.text = "%.3f" % impact
		fer_value.text = "%.3f" % ferocity
		fur_value.text = "%.3f" % fury
		sta_value.text = "%.3f" % stamina
		end_value.text = "%.3f" % endurance
		ten_value.text = "%.3f" % tenacity
		dex_value.text = "%.3f" % dexterity
		acc_value.text = "%.3f" % accuracy
		foc_value.text = "%.3f" % focus
		poi_value.text = "%.3f" % poise
		bal_value.text = "%.3f" % balance
		cha_value.text = "%.3f" % charisma
		dip_value.text = "%.3f" % diplomacy
		agi_value.text = "%.3f" % agility
		aut_value.text = "%.3f" % authority
		cou_value.text = "%.3f" % courage
		loy_value.text = "%.3f" % loyalty
		has_value.text = "%.3f" % haste
		cel_value.text = "%.3f" % celerity
		fle_value.text = "%.3f" % flexibility
		def_value.text = "%.3f" % deflection
func resistanceMath():
	var additional_resistance = 0
	var res_multiplier = 0.5
	if resistance > 1:
		additional_resistance = res_multiplier * (resistance - 1)
	elif resistance < 1:
		additional_resistance = -res_multiplier * (1 - resistance)
	defense = base_defense + int(resistance * 10)
	max_health = (base_max_health * (vitality + additional_resistance)) * scale_factor
	max_energy = base_max_energy * (stamina  + additional_resistance)
	max_resolve = base_max_resolve * (tenacity + additional_resistance)
	
const base_melee_atk_speed = 1 
var melee_atk_speed = 1 
const base_ranged_atk_speed = 1 
var ranged_atk_speed = 1 
const base_casting_speed = 1 
var casting_speed = 1 
func updateAttackSpeed():
	var bonus_universal_speed = (celerity -1) * 0.15
	var atk_speed_formula = (dexterity - scale_factor ) * 0.5 
	melee_atk_speed = base_melee_atk_speed + atk_speed_formula + bonus_universal_speed
	var atk_speed_formula_ranged = (strength -1) * 0.5
	ranged_atk_speed = base_ranged_atk_speed + atk_speed_formula_ranged + bonus_universal_speed
	var atk_speed_formula_casting = (instinct -1) * 0.35 + ((memory-1) * 0.05) + bonus_universal_speed
	casting_speed = base_casting_speed + atk_speed_formula_casting
	#display the labels
	$BookStatsSkills/CombatStats/GridContainer/CastingSpeedValue.text = str(casting_speed)
	$BookStatsSkills/CombatStats/GridContainer/RangedSpeedValue.text = str(ranged_atk_speed)
	$BookStatsSkills/CombatStats/GridContainer/AtkSpeedValue.text = str(melee_atk_speed)
var critical_chance = 0.00
var critical_strength = 2
func updateCritical():
	critical_chance = max(0, (accuracy - 1.00) * 0.5) +  max(0, (impact - 1.00) * 0.005) 
	critical_strength = ((ferocity -1) * 2) 
	critical_chance_val.text = str(round(critical_chance * 100 * 1000) / 1000) + "%"
	critical_str_val.text = "x" + str(critical_strength)
var stagger_chance = 0.00
func updateStaggerChance():
	stagger_chance = max(0, (impact - 1.00) * 0.45) +  max(0, (ferocity - 1.00) * 0.005) 
	$BookStatsSkills/CombatStats/GridContainer/StaggerChanceValue.text = str(stagger_chance)
var life_steal = 1 
func updateLifeSteal():
	life_steal_value.text = str(life_steal * 100) + "%"
func updateScaleRelatedAttributes():
	charisma = base_charisma * (charisma_multiplier * 0.87 * (scale_factor * 1.15))
func UpdateAllStats():
	updateAttackSpeed()
	updateScaleRelatedAttributes()
	updateCritical()
	updateLifeSteal()
	updateStaggerChance()
func manageEnergy():
	if is_running:
		if energy >0:
			energy -= 1 * scale_factor
		if energy < 0:
			energy = 0 
	elif is_sprinting:
		if energy >0:
			energy -= 1.5 * scale_factor
		if energy < 0:
			energy = 0 
	else:
		if energy < max_energy:
			energy += endurance + (fury * 0.25)
		elif energy > max_energy:
			energy = max_energy
var attribute_increase_factor = 0.1
var minimum_att_value = 0.005
var attribute = 1000
#intelligence
func _on_PlusInt_pressed():
	if attribute >0:
		if spent_attribute_points_int < 5:
			spent_attribute_points_int += 1
			attribute -= 1 
			intelligence += attribute_increase_factor
		elif spent_attribute_points_int < 10:
			spent_attribute_points_int += 1
			attribute -= 1 
			intelligence += attribute_increase_factor * 0.5
		elif spent_attribute_points_int < 15:
			spent_attribute_points_int += 1
			attribute -= 1 
			intelligence += attribute_increase_factor * 0.2
		elif spent_attribute_points_int < 20:
			spent_attribute_points_int += 1
			attribute -= 1
			intelligence += attribute_increase_factor * 0.1
		elif spent_attribute_points_int < 25:
			spent_attribute_points_int += 1
			attribute -= 1 
			intelligence += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_int += 1
			attribute -= 1 
			intelligence += attribute_increase_factor * 0.01
func _on_MinInt_pressed():
	if intelligence > 0.05:
		spent_attribute_points_int -= 1
		attribute += 1 
		if spent_attribute_points_int < 5:
			intelligence -= attribute_increase_factor
		elif spent_attribute_points_int < 10:
			intelligence -= attribute_increase_factor * 0.5
		elif spent_attribute_points_int < 15:
			intelligence -= attribute_increase_factor * 0.2
		elif spent_attribute_points_int < 20:
			intelligence -= attribute_increase_factor * 0.1
		elif spent_attribute_points_int < 25:
			intelligence -= attribute_increase_factor * 0.05
		else:
			intelligence -= attribute_increase_factor * 0.01
#Instincts
func _on_PlusIns_pressed():
	if attribute > 0:
		if spent_attribute_points_ins < 5:
			spent_attribute_points_ins += 1
			attribute -= 1
			instinct += attribute_increase_factor
		elif spent_attribute_points_ins < 10:
			spent_attribute_points_ins += 1
			attribute -= 1
			instinct += attribute_increase_factor * 0.5
		elif spent_attribute_points_ins < 15:
			spent_attribute_points_ins += 1
			attribute -= 1
			instinct += attribute_increase_factor * 0.2
		elif spent_attribute_points_ins < 20:
			spent_attribute_points_ins += 1
			attribute -= 1
			instinct += attribute_increase_factor * 0.1
		elif spent_attribute_points_ins < 25:
			spent_attribute_points_ins += 1
			attribute -= 1
			instinct += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_ins += 1
			attribute -= 1
			instinct += attribute_increase_factor * 0.01
func _on_MinIns_pressed():
	if instinct > 0.05:
		spent_attribute_points_ins -= 1
		attribute += 1
		if spent_attribute_points_ins < 5:
			instinct -= attribute_increase_factor
		elif spent_attribute_points_ins < 10:
			instinct -= attribute_increase_factor * 0.5
		elif spent_attribute_points_ins < 15:
			instinct -= attribute_increase_factor * 0.2
		elif spent_attribute_points_ins < 20:
			instinct -= attribute_increase_factor * 0.1
		elif spent_attribute_points_ins < 25:
			instinct -= attribute_increase_factor * 0.05
		else:
			instinct -= attribute_increase_factor * 0.01
# Wisdom
func _on_PlusWis_pressed():
	if attribute > 0:
		if spent_attribute_points_wis < 5:
			spent_attribute_points_wis += 1
			attribute -= 1
			wisdom += attribute_increase_factor
		elif spent_attribute_points_wis < 10:
			spent_attribute_points_wis += 1
			attribute -= 1
			wisdom += attribute_increase_factor * 0.5
		elif spent_attribute_points_wis < 15:
			spent_attribute_points_wis += 1
			attribute -= 1
			wisdom += attribute_increase_factor * 0.2
		elif spent_attribute_points_wis < 20:
			spent_attribute_points_wis += 1
			attribute -= 1
			wisdom += attribute_increase_factor * 0.1
		elif spent_attribute_points_wis < 25:
			spent_attribute_points_wis += 1
			attribute -= 1
			wisdom += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_wis += 1
			attribute -= 1
			wisdom += attribute_increase_factor * 0.01
func _on_MinWis_pressed():
	if wisdom > 0.05:
		spent_attribute_points_wis -= 1
		attribute += 1
		if spent_attribute_points_wis < 5:
			wisdom -= attribute_increase_factor
		elif spent_attribute_points_wis < 10:
			wisdom -= attribute_increase_factor * 0.5
		elif spent_attribute_points_wis < 15:
			wisdom -= attribute_increase_factor * 0.2
		elif spent_attribute_points_wis < 20:
			wisdom -= attribute_increase_factor * 0.1
		elif spent_attribute_points_wis < 25:
			wisdom -= attribute_increase_factor * 0.05
		else:
			wisdom -= attribute_increase_factor * 0.01
# Memory
func _on_PlusMem_pressed():
	if attribute > 0:
		if spent_attribute_points_mem < 5:
			spent_attribute_points_mem += 1
			attribute -= 1
			memory += attribute_increase_factor
		elif spent_attribute_points_mem < 10:
			spent_attribute_points_mem += 1
			attribute -= 1
			memory += attribute_increase_factor * 0.5
		elif spent_attribute_points_mem < 15:
			spent_attribute_points_mem += 1
			attribute -= 1
			memory += attribute_increase_factor * 0.2
		elif spent_attribute_points_mem < 20:
			spent_attribute_points_mem += 1
			attribute -= 1
			memory += attribute_increase_factor * 0.1
		elif spent_attribute_points_mem < 25:
			spent_attribute_points_mem += 1
			attribute -= 1
			memory += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_mem += 1
			attribute -= 1
			memory += attribute_increase_factor * 0.01
func _on_MinMem_pressed():
	if memory > 0.05:
		spent_attribute_points_mem -= 1
		attribute += 1
		if spent_attribute_points_mem < 5:
			memory -= attribute_increase_factor
		elif spent_attribute_points_mem < 10:
			memory -= attribute_increase_factor * 0.5
		elif spent_attribute_points_mem < 15:
			memory -= attribute_increase_factor * 0.2
		elif spent_attribute_points_mem < 20:
			memory -= attribute_increase_factor * 0.1
		elif spent_attribute_points_mem < 25:
			memory -= attribute_increase_factor * 0.05
		else:
			memory -= attribute_increase_factor * 0.01
# Sanity
func _on_PlusSan_pressed():
	if attribute > 0:
		if spent_attribute_points_san < 5:
			spent_attribute_points_san += 1
			attribute -= 1
			sanity += attribute_increase_factor
		elif spent_attribute_points_san < 10:
			spent_attribute_points_san += 1
			attribute -= 1
			sanity += attribute_increase_factor * 0.5
		elif spent_attribute_points_san < 15:
			spent_attribute_points_san += 1
			attribute -= 1
			sanity += attribute_increase_factor * 0.2
		elif spent_attribute_points_san < 20:
			spent_attribute_points_san += 1
			attribute -= 1
			sanity += attribute_increase_factor * 0.1
		elif spent_attribute_points_san < 25:
			spent_attribute_points_san += 1
			attribute -= 1
			sanity += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_san += 1
			attribute -= 1
			sanity += attribute_increase_factor * 0.01
func _on_MinSan_pressed():
	if sanity > 0.05:
		spent_attribute_points_san -= 1
		attribute += 1
		if spent_attribute_points_san < 5:
			sanity -= attribute_increase_factor
		elif spent_attribute_points_san < 10:
			sanity -= attribute_increase_factor * 0.5
		elif spent_attribute_points_san < 15:
			sanity -= attribute_increase_factor * 0.2
		elif spent_attribute_points_san < 20:
			sanity -= attribute_increase_factor * 0.1
		elif spent_attribute_points_san < 25:
			sanity -= attribute_increase_factor * 0.05
		else:
			sanity -= attribute_increase_factor * 0.01
#Strength
func _on_PlusStr_pressed():
	if attribute > 0:
		if spent_attribute_points_str < 5:
			spent_attribute_points_str += 1
			attribute -= 1
			strength += attribute_increase_factor
		elif spent_attribute_points_str < 10:
			spent_attribute_points_str += 1
			attribute -= 1
			strength += attribute_increase_factor * 0.5
		elif spent_attribute_points_str < 15:
			spent_attribute_points_str += 1
			attribute -= 1
			strength += attribute_increase_factor * 0.2
		elif spent_attribute_points_str < 20:
			spent_attribute_points_str += 1
			attribute -= 1
			strength += attribute_increase_factor * 0.1
		elif spent_attribute_points_str < 25:
			spent_attribute_points_str += 1
			attribute -= 1
			strength += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_str += 1
			attribute -= 1
			strength += attribute_increase_factor * 0.01
func _on_MinStr_pressed():
	if strength > 0.05:
		spent_attribute_points_str -= 1
		attribute += 1
		if spent_attribute_points_str < 5:
			strength -= attribute_increase_factor
		elif spent_attribute_points_str < 10:
			strength -= attribute_increase_factor * 0.5
		elif spent_attribute_points_str < 15:
			strength -= attribute_increase_factor * 0.2
		elif spent_attribute_points_str < 20:
			strength -= attribute_increase_factor * 0.1
		elif spent_attribute_points_str < 25:
			strength -= attribute_increase_factor * 0.05
		else:
			strength -= attribute_increase_factor * 0.01
#Force
func _on_PlusFor_pressed():
	if attribute > 0:
		if spent_attribute_points_for < 5:
			spent_attribute_points_for += 1
			attribute -= 1
			force += attribute_increase_factor
		elif spent_attribute_points_for < 10:
			spent_attribute_points_for += 1
			attribute -= 1
			force += attribute_increase_factor * 0.5
		elif spent_attribute_points_for < 15:
			spent_attribute_points_for += 1
			attribute -= 1
			force += attribute_increase_factor * 0.2
		elif spent_attribute_points_for < 20:
			spent_attribute_points_for += 1
			attribute -= 1
			force += attribute_increase_factor * 0.1
		elif spent_attribute_points_for < 25:
			spent_attribute_points_for += 1
			attribute -= 1
			force += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_for += 1
			attribute -= 1
			force += attribute_increase_factor * 0.01
func _on_MinFor_pressed():
	if force > 0.05:
		spent_attribute_points_for -= 1
		attribute += 1
		if spent_attribute_points_for < 5:
			force -= attribute_increase_factor
		elif spent_attribute_points_for < 10:
			force -= attribute_increase_factor * 0.5
		elif spent_attribute_points_for < 15:
			force -= attribute_increase_factor * 0.2
		elif spent_attribute_points_for < 20:
			force -= attribute_increase_factor * 0.1
		elif spent_attribute_points_for < 25:
			force -= attribute_increase_factor * 0.05
		else:
			force -= attribute_increase_factor * 0.01
#Impact
func _on_PlusImp_pressed():
	if attribute > 0:
		if spent_attribute_points_imp < 5:
			spent_attribute_points_imp += 1
			attribute -= 1
			impact += attribute_increase_factor
		elif spent_attribute_points_imp < 10:
			spent_attribute_points_imp += 1
			attribute -= 1
			impact += attribute_increase_factor * 0.5
		elif spent_attribute_points_imp < 15:
			spent_attribute_points_imp += 1
			attribute -= 1
			impact += attribute_increase_factor * 0.2
		elif spent_attribute_points_imp < 20:
			spent_attribute_points_imp += 1
			attribute -= 1
			impact += attribute_increase_factor * 0.1
		elif spent_attribute_points_imp < 25:
			spent_attribute_points_imp += 1
			attribute -= 1
			impact += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_imp += 1
			attribute -= 1
			impact += attribute_increase_factor * 0.01
func _on_MinImp_pressed():
	if impact > 0.05:
		spent_attribute_points_imp -= 1
		attribute += 1
		if spent_attribute_points_imp < 5:
			impact -= attribute_increase_factor
		elif spent_attribute_points_imp < 10:
			impact -= attribute_increase_factor * 0.5
		elif spent_attribute_points_imp < 15:
			impact -= attribute_increase_factor * 0.2
		elif spent_attribute_points_imp < 20:
			impact -= attribute_increase_factor * 0.1
		elif spent_attribute_points_imp < 25:
			impact -= attribute_increase_factor * 0.05
		else:
			impact -= attribute_increase_factor * 0.01
#Ferocity
func _on_PlusFer_pressed():
	if attribute > 0:
		if spent_attribute_points_fer < 5:
			spent_attribute_points_fer += 1
			attribute -= 1
			ferocity += attribute_increase_factor
		elif spent_attribute_points_fer < 10:
			spent_attribute_points_fer += 1
			attribute -= 1
			ferocity += attribute_increase_factor * 0.5
		elif spent_attribute_points_fer < 15:
			spent_attribute_points_fer += 1
			attribute -= 1
			ferocity += attribute_increase_factor * 0.2
		elif spent_attribute_points_fer < 20:
			spent_attribute_points_fer += 1
			attribute -= 1
			ferocity += attribute_increase_factor * 0.1
		elif spent_attribute_points_fer < 25:
			spent_attribute_points_fer += 1
			attribute -= 1
			ferocity += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_fer += 1
			attribute -= 1
			ferocity += attribute_increase_factor * 0.01
func _on_MinFer_pressed():
	if ferocity > 0.05:
		spent_attribute_points_fer -= 1
		attribute += 1
		if spent_attribute_points_fer < 5:
			ferocity -= attribute_increase_factor
		elif spent_attribute_points_fer < 10:
			ferocity -= attribute_increase_factor * 0.5
		elif spent_attribute_points_fer < 15:
			ferocity -= attribute_increase_factor * 0.2
		elif spent_attribute_points_fer < 20:
			ferocity -= attribute_increase_factor * 0.1
		elif spent_attribute_points_fer < 25:
			ferocity -= attribute_increase_factor * 0.05
		else:
			ferocity -= attribute_increase_factor * 0.01
#Fury
func _on_PlusFur_pressed():
	if attribute > 0:
		if spent_attribute_points_fur < 5:
			spent_attribute_points_fur += 1
			attribute -= 1
			fury += attribute_increase_factor
		elif spent_attribute_points_fur < 10:
			spent_attribute_points_fur += 1
			attribute -= 1
			fury += attribute_increase_factor * 0.5
		elif spent_attribute_points_fur < 15:
			spent_attribute_points_fur+= 1
			attribute -= 1
			fury += attribute_increase_factor * 0.2
		elif spent_attribute_points_fur < 20:
			spent_attribute_points_fur += 1
			attribute -= 1
			fury += attribute_increase_factor * 0.1
		elif spent_attribute_points_fur < 25:
			spent_attribute_points_fur += 1
			attribute -= 1
			fury += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_fur += 1
			attribute -= 1
			fury += attribute_increase_factor * 0.01
func _on_MinFur_pressed():
	if fury > 0.05:
		spent_attribute_points_fur -= 1
		attribute += 1
		if spent_attribute_points_fur < 5:
			fury -= attribute_increase_factor
		elif spent_attribute_points_fur < 10:
			fury -= attribute_increase_factor * 0.5
		elif spent_attribute_points_fur < 15:
			fury -= attribute_increase_factor * 0.2
		elif spent_attribute_points_fur < 20:
			fury -= attribute_increase_factor * 0.1
		elif spent_attribute_points_fur < 25:
			fury -= attribute_increase_factor * 0.05
		else:
			fury -= attribute_increase_factor * 0.01
#Vitality, for now it only increases health 
func _on_PlusVit_pressed():
	if attribute > 0:
		if spent_attribute_points_vit < 5:
			spent_attribute_points_vit += 1
			attribute -= 1
			vitality += attribute_increase_factor
		elif spent_attribute_points_vit < 10:
			spent_attribute_points_vit += 1
			attribute -= 1
			vitality += attribute_increase_factor * 0.5
		elif spent_attribute_points_vit < 15:
			spent_attribute_points_vit += 1
			attribute -= 1
			vitality += attribute_increase_factor * 0.2
		elif spent_attribute_points_vit < 20:
			spent_attribute_points_vit += 1
			attribute -= 1
			vitality += attribute_increase_factor * 0.1
		elif spent_attribute_points_vit < 25:
			spent_attribute_points_vit += 1
			attribute -= 1
			vitality += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_vit += 1
			attribute -= 1
			vitality += attribute_increase_factor * 0.01
func _on_MinVit_pressed():
	if vitality > 0.05:
		spent_attribute_points_vit -= 1
		attribute += 1
		if spent_attribute_points_vit < 5:
			vitality -= attribute_increase_factor
		elif spent_attribute_points_vit < 10:
			vitality -= attribute_increase_factor * 0.5
		elif spent_attribute_points_vit < 15:
			vitality -= attribute_increase_factor * 0.2
		elif spent_attribute_points_vit < 20:
			vitality -= attribute_increase_factor * 0.1
		elif spent_attribute_points_vit < 25:
			vitality -= attribute_increase_factor * 0.05
		else:
			vitality -= attribute_increase_factor * 0.01
#Stamina 
func _on_PlusSta_pressed():
	if attribute > 0:
		if spent_attribute_points_sta < 5:
			spent_attribute_points_sta += 1
			attribute -= 1
			stamina += attribute_increase_factor
		elif spent_attribute_points_sta < 10:
			spent_attribute_points_sta += 1
			attribute -= 1
			stamina += attribute_increase_factor * 0.5
		elif spent_attribute_points_sta < 15:
			spent_attribute_points_sta += 1
			attribute -= 1
			stamina += attribute_increase_factor * 0.2
		elif spent_attribute_points_sta < 20:
			spent_attribute_points_sta += 1
			attribute -= 1
			stamina += attribute_increase_factor * 0.1
		elif spent_attribute_points_sta < 25:
			spent_attribute_points_sta += 1
			attribute -= 1
			stamina += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_sta += 1
			attribute -= 1
			stamina += attribute_increase_factor * 0.01
func _on_MinSta_pressed():
	if stamina > 0.05:
		spent_attribute_points_sta -= 1
		attribute += 1
		if spent_attribute_points_sta < 5:
			stamina -= attribute_increase_factor
		elif spent_attribute_points_sta < 10:
			stamina -= attribute_increase_factor * 0.5
		elif spent_attribute_points_sta < 15:
			stamina -= attribute_increase_factor * 0.2
		elif spent_attribute_points_sta < 20:
			stamina -= attribute_increase_factor * 0.1
		elif spent_attribute_points_sta < 25:
			stamina -= attribute_increase_factor * 0.05
		else:
			stamina -= attribute_increase_factor * 0.01
#Endurance
func _on_PlusEnd_pressed():
	if attribute > 0:
		if spent_attribute_points_end < 5:
			spent_attribute_points_end += 1
			attribute -= 1
			endurance += attribute_increase_factor
		elif spent_attribute_points_end < 10:
			spent_attribute_points_end += 1
			attribute -= 1
			endurance += attribute_increase_factor * 0.5
		elif spent_attribute_points_end < 15:
			spent_attribute_points_end += 1
			attribute -= 1
			endurance += attribute_increase_factor * 0.2
		elif spent_attribute_points_end < 20:
			spent_attribute_points_end += 1
			attribute -= 1
			endurance += attribute_increase_factor * 0.1
		elif spent_attribute_points_end < 25:
			spent_attribute_points_end += 1
			attribute -= 1
			endurance += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_end += 1
			attribute -= 1
			endurance += attribute_increase_factor * 0.01
func _on_MinEnd_pressed():
	if endurance > 0.05:
		spent_attribute_points_end -= 1
		attribute += 1
		if spent_attribute_points_end < 5:
			endurance -= attribute_increase_factor
		elif spent_attribute_points_end < 10:
			endurance -= attribute_increase_factor * 0.5
		elif spent_attribute_points_end < 15:
			endurance -= attribute_increase_factor * 0.2
		elif spent_attribute_points_end < 20:
			endurance -= attribute_increase_factor * 0.1
		elif spent_attribute_points_end < 25:
			endurance -= attribute_increase_factor * 0.05
		else:
			endurance -= attribute_increase_factor * 0.01

#Resistance, it increases health, energy, resolve, defense at 1/3 value of other attributes
func _on_PlusRes_pressed():
	if attribute > 0:
		if spent_attribute_points_res < 5:
			spent_attribute_points_res += 1
			attribute -= 1
			resistance += attribute_increase_factor
		elif spent_attribute_points_res < 10:
			spent_attribute_points_res += 1
			attribute -= 1
			resistance += attribute_increase_factor * 0.5
		elif spent_attribute_points_res < 15:
			spent_attribute_points_res += 1
			attribute -= 1
			resistance += attribute_increase_factor * 0.2
		elif spent_attribute_points_res < 20:
			spent_attribute_points_res += 1
			attribute -= 1
			resistance += attribute_increase_factor * 0.1
		elif spent_attribute_points_res < 25:
			spent_attribute_points_res += 1
			attribute -= 1
			resistance += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_res += 1
			attribute -= 1
			resistance += attribute_increase_factor * 0.01
func _on_MinRes_pressed():
	if resistance > 0.05:
		spent_attribute_points_res -= 1
		attribute += 1
		if spent_attribute_points_res < 5:
			resistance -= attribute_increase_factor
		elif spent_attribute_points_res < 10:
			resistance -= attribute_increase_factor * 0.5
		elif spent_attribute_points_res < 15:
			resistance -= attribute_increase_factor * 0.2
		elif spent_attribute_points_res < 20:
			resistance -= attribute_increase_factor * 0.1
		elif spent_attribute_points_res < 25:
			resistance -= attribute_increase_factor * 0.05
		else:
			resistance -= attribute_increase_factor * 0.01
#Tenacity
func _on_PlusTen_pressed():
	if attribute > 0:
		if spent_attribute_points_ten < 5:
			spent_attribute_points_ten += 1
			attribute -= 1
			tenacity += attribute_increase_factor
		elif spent_attribute_points_ten < 10:
			spent_attribute_points_ten += 1
			attribute -= 1
			tenacity += attribute_increase_factor * 0.5
		elif spent_attribute_points_ten < 15:
			spent_attribute_points_ten += 1
			attribute -= 1
			tenacity += attribute_increase_factor * 0.2
		elif spent_attribute_points_ten < 20:
			spent_attribute_points_ten += 1
			attribute -= 1
			tenacity += attribute_increase_factor * 0.1
		elif spent_attribute_points_ten < 25:
			spent_attribute_points_ten += 1
			attribute -= 1
			tenacity += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_ten += 1
			attribute -= 1
			tenacity += attribute_increase_factor * 0.0
func _on_MinTen_pressed():
	if tenacity > 0.05:
		spent_attribute_points_ten -= 1
		attribute += 1
		if spent_attribute_points_ten < 5:
			tenacity -= attribute_increase_factor
		elif spent_attribute_points_ten < 10:
			tenacity -= attribute_increase_factor * 0.5
		elif spent_attribute_points_ten < 15:
			tenacity -= attribute_increase_factor * 0.2
		elif spent_attribute_points_ten < 20:
			tenacity -= attribute_increase_factor * 0.1
		elif spent_attribute_points_ten < 25:
			tenacity -= attribute_increase_factor * 0.05
		else:
			tenacity -= attribute_increase_factor * 0.01
#Agility 
func _on_PlusAgi_pressed():
	if attribute > 0:
		if spent_attribute_points_agi < 5:
			spent_attribute_points_agi += 1
			attribute -= 1
			agility += attribute_increase_factor
		elif spent_attribute_points_agi < 10:
			spent_attribute_points_agi += 1
			attribute -= 1
			agility += attribute_increase_factor * 0.5
		elif spent_attribute_points_agi < 15:
			spent_attribute_points_agi += 1
			attribute -= 1
			agility += attribute_increase_factor * 0.2
		elif spent_attribute_points_agi < 20:
			spent_attribute_points_agi += 1
			attribute -= 1
			agility += attribute_increase_factor * 0.1
		elif spent_attribute_points_agi < 25:
			spent_attribute_points_agi += 1
			attribute -= 1
			agility += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_agi += 1
			attribute -= 1
			agility += attribute_increase_factor * 0.01
func _on_MinAgi_pressed():
	if agility > 0.05:
		spent_attribute_points_agi -= 1
		attribute += 1
		if spent_attribute_points_agi < 5:
			agility -= attribute_increase_factor
		elif spent_attribute_points_agi < 10:
			agility -= attribute_increase_factor * 0.5
		elif spent_attribute_points_agi < 15:
			agility -= attribute_increase_factor * 0.2
		elif spent_attribute_points_agi < 20:
			agility -= attribute_increase_factor * 0.1
		elif spent_attribute_points_agi < 25:
			agility -= attribute_increase_factor * 0.05
		else:
			agility -= attribute_increase_factor * 0.01
#Haste
func _on_PlusHas_pressed():
	if attribute > 0:
		if spent_attribute_points_has < 5:
			spent_attribute_points_has += 1
			attribute -= 1
			haste += attribute_increase_factor
		elif spent_attribute_points_has < 10:
			spent_attribute_points_has += 1
			attribute -= 1
			haste += attribute_increase_factor * 0.5
		elif spent_attribute_points_has < 15:
			spent_attribute_points_has += 1
			attribute -= 1
			haste += attribute_increase_factor * 0.2
		elif spent_attribute_points_has < 20:
			spent_attribute_points_has += 1
			attribute -= 1
			haste += attribute_increase_factor * 0.1
		elif spent_attribute_points_has < 25:
			spent_attribute_points_has += 1
			attribute -= 1
			haste += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_has += 1
			attribute -= 1
			haste += attribute_increase_factor * 0.01
func _on_MinHas_pressed():
	if haste > 0.05:
		spent_attribute_points_has -= 1
		attribute += 1
		if spent_attribute_points_has < 5:
			haste -= attribute_increase_factor
		elif spent_attribute_points_has < 10:
			haste -= attribute_increase_factor * 0.5
		elif spent_attribute_points_has < 15:
			haste -= attribute_increase_factor * 0.2
		elif spent_attribute_points_has < 20:
			haste -= attribute_increase_factor * 0.1
		elif spent_attribute_points_has < 25:
			haste -= attribute_increase_factor * 0.05
		else:
			haste -= attribute_increase_factor * 0.01
#Celerety 
func _on_PlusCel_pressed():
	if attribute > 0:
		if spent_attribute_points_cel < 5:
			spent_attribute_points_cel += 1
			attribute -= 1
			celerity += attribute_increase_factor
		elif spent_attribute_points_cel < 10:
			spent_attribute_points_cel += 1
			attribute -= 1
			celerity += attribute_increase_factor * 0.5
		elif spent_attribute_points_cel < 15:
			spent_attribute_points_cel += 1
			attribute -= 1
			celerity += attribute_increase_factor * 0.2
		elif spent_attribute_points_cel < 20:
			spent_attribute_points_cel += 1
			attribute -= 1
			celerity += attribute_increase_factor * 0.1
		elif spent_attribute_points_cel < 25:
			spent_attribute_points_cel += 1
			attribute -= 1
			celerity += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_cel += 1
			attribute -= 1
			celerity += attribute_increase_factor * 0.01
func _on_MinCel_pressed():
	if celerity > 0.05:
		spent_attribute_points_cel -= 1
		attribute += 1
		if spent_attribute_points_cel < 5:
			celerity -= attribute_increase_factor
		elif spent_attribute_points_cel < 10:
			celerity -= attribute_increase_factor * 0.5
		elif spent_attribute_points_cel < 15:
			celerity -= attribute_increase_factor * 0.2
		elif spent_attribute_points_cel < 20:
			celerity -= attribute_increase_factor * 0.1
		elif spent_attribute_points_cel < 25:
			celerity -= attribute_increase_factor * 0.05
		else:
			celerity -= attribute_increase_factor * 0.01
#Flexibity.... this is mostly about taking less falling damage or when being knocked down by tackles 
func _on_PlusFle_pressed():
	if attribute > 0:
		if spent_attribute_points_fle < 5:
			spent_attribute_points_fle += 1
			attribute -= 1
			flexibility += attribute_increase_factor
		elif spent_attribute_points_fle< 10:
			spent_attribute_points_fle += 1
			attribute -= 1
			flexibility += attribute_increase_factor * 0.5
		elif spent_attribute_points_fle < 15:
			spent_attribute_points_fle += 1
			attribute -= 1
			flexibility += attribute_increase_factor * 0.2
		elif spent_attribute_points_fle< 20:
			spent_attribute_points_fle += 1
			attribute -= 1
			flexibility += attribute_increase_factor * 0.1
		elif spent_attribute_points_fle < 25:
			spent_attribute_points_fle += 1
			attribute -= 1
			flexibility += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_fle += 1
			attribute -= 1
			flexibility += attribute_increase_factor * 0.01
func _on_MinFle_pressed():
	if flexibility > 0.05:
		spent_attribute_points_fle -= 1
		attribute += 1
		if spent_attribute_points_fle < 5:
			flexibility -= attribute_increase_factor
		elif spent_attribute_points_fle < 10:
			flexibility -= attribute_increase_factor * 0.5
		elif spent_attribute_points_fle < 15:
			flexibility -= attribute_increase_factor * 0.2
		elif spent_attribute_points_fle < 20:
			flexibility -= attribute_increase_factor * 0.1
		elif spent_attribute_points_fle < 25:
			flexibility -= attribute_increase_factor * 0.05
		else:
			flexibility -= attribute_increase_factor * 0.01

#Deflextion, influence chance to take less damage, kind of opposite of critical hits
# Deflection
func _on_PlusDef_pressed():
	if attribute > 0:
		if spent_attribute_points_def < 5:
			spent_attribute_points_def += 1
			attribute -= 1
			deflection += attribute_increase_factor
		elif spent_attribute_points_def < 10:
			spent_attribute_points_def += 1
			attribute -= 1
			deflection += attribute_increase_factor * 0.5
		elif spent_attribute_points_def < 15:
			spent_attribute_points_def += 1
			attribute -= 1
			deflection += attribute_increase_factor * 0.2
		elif spent_attribute_points_def < 20:
			spent_attribute_points_def += 1
			attribute -= 1
			deflection += attribute_increase_factor * 0.1
		elif spent_attribute_points_def < 25:
			spent_attribute_points_def += 1
			attribute -= 1
			deflection += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_def += 1
			attribute -= 1
			deflection += attribute_increase_factor * 0.01
func _on_MinDef_pressed():
	if deflection > 0.05:
		spent_attribute_points_def -= 1
		attribute += 1
		if spent_attribute_points_def < 5:
			deflection -= attribute_increase_factor
		elif spent_attribute_points_def < 10:
			deflection -= attribute_increase_factor * 0.5
		elif spent_attribute_points_def < 15:
			deflection -= attribute_increase_factor * 0.2
		elif spent_attribute_points_def < 20:
			deflection -= attribute_increase_factor * 0.1
		elif spent_attribute_points_def < 25:
			deflection -= attribute_increase_factor * 0.05
		else:
			deflection -= attribute_increase_factor * 0.01
#Dexterity
func _on_PlusDex_pressed():
	if attribute > 0:
		if spent_attribute_points_dex < 5:
			spent_attribute_points_dex += 1
			attribute -= 1
			dexterity += attribute_increase_factor
		elif spent_attribute_points_dex < 10:
			spent_attribute_points_dex += 1
			attribute -= 1
			dexterity += attribute_increase_factor * 0.5
		elif spent_attribute_points_dex < 15:
			spent_attribute_points_dex += 1
			attribute -= 1
			dexterity += attribute_increase_factor * 0.2
		elif spent_attribute_points_dex < 20:
			spent_attribute_points_dex += 1
			attribute -= 1
			dexterity += attribute_increase_factor * 0.1
		elif spent_attribute_points_dex < 25:
			spent_attribute_points_dex += 1
			attribute -= 1
			dexterity += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_dex += 1
			attribute -= 1
			dexterity += attribute_increase_factor * 0.01
func _on_MinDex_pressed():
	if dexterity > 0.05:
		spent_attribute_points_dex -= 1
		attribute += 1
		if spent_attribute_points_dex < 5:
			dexterity -= attribute_increase_factor
		elif spent_attribute_points_dex < 10:
			dexterity -= attribute_increase_factor * 0.5
		elif spent_attribute_points_dex < 15:
			dexterity -= attribute_increase_factor * 0.2
		elif spent_attribute_points_dex < 20:
			dexterity -= attribute_increase_factor * 0.1
		elif spent_attribute_points_dex < 25:
			dexterity -= attribute_increase_factor * 0.05
		else:
			dexterity -= attribute_increase_factor * 0.01
#Accuracy
func _on_PlusAcc_pressed():
	if attribute > 0:
		if spent_attribute_points_acc < 5:
			spent_attribute_points_acc += 1
			attribute -= 1
			accuracy += attribute_increase_factor
		elif spent_attribute_points_acc < 10:
			spent_attribute_points_acc += 1
			attribute -= 1
			accuracy += attribute_increase_factor * 0.5
		elif spent_attribute_points_acc < 15:
			spent_attribute_points_acc += 1
			attribute -= 1
			accuracy += attribute_increase_factor * 0.2
		elif spent_attribute_points_acc < 20:
			spent_attribute_points_acc += 1
			attribute -= 1
			accuracy += attribute_increase_factor * 0.1
		elif spent_attribute_points_acc < 25:
			spent_attribute_points_acc += 1
			attribute -= 1
			accuracy += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_acc += 1
			attribute -= 1
			accuracy += attribute_increase_factor * 0.01
func _on_MinAcc_pressed():
	if accuracy > 0.05:
		spent_attribute_points_acc -= 1
		attribute += 1
		if spent_attribute_points_acc < 5:
			accuracy -= attribute_increase_factor
		elif spent_attribute_points_acc < 10:
			accuracy -= attribute_increase_factor * 0.5
		elif spent_attribute_points_acc < 15:
			accuracy -= attribute_increase_factor * 0.2
		elif spent_attribute_points_acc < 20:
			accuracy -= attribute_increase_factor * 0.1
		elif spent_attribute_points_acc < 25:
			accuracy -= attribute_increase_factor * 0.05
		else:
			accuracy -= attribute_increase_factor * 0.01
#Focus
func _on_PlusFoc_pressed():
	if attribute > 0:
		if spent_attribute_points_foc < 5:
			spent_attribute_points_foc += 1
			attribute -= 1
			focus += attribute_increase_factor
		elif spent_attribute_points_foc < 10:
			spent_attribute_points_foc += 1
			attribute -= 1
			focus += attribute_increase_factor * 0.5
		elif spent_attribute_points_foc < 15:
			spent_attribute_points_foc += 1
			attribute -= 1
			focus += attribute_increase_factor * 0.2
		elif spent_attribute_points_foc < 20:
			spent_attribute_points_foc += 1
			attribute -= 1
			focus += attribute_increase_factor * 0.1
		elif spent_attribute_points_foc < 25:
			spent_attribute_points_foc += 1
			attribute -= 1
			focus += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_foc += 1
			attribute -= 1
			focus += attribute_increase_factor * 0.01
func _on_MinFoc_pressed():
	if focus > 0.05:
		spent_attribute_points_foc -= 1
		attribute += 1
		if spent_attribute_points_foc < 5:
			focus -= attribute_increase_factor
		elif spent_attribute_points_foc < 10:
			focus -= attribute_increase_factor * 0.5
		elif spent_attribute_points_foc < 15:
			focus -= attribute_increase_factor * 0.2
		elif spent_attribute_points_foc < 20:
			focus -= attribute_increase_factor * 0.1
		elif spent_attribute_points_foc < 25:
			focus -= attribute_increase_factor * 0.05
		else:
			focus -= attribute_increase_factor * 0.01
#Poise 
func _on_PlusPoi_pressed():
	if attribute > 0:
		if spent_attribute_points_poi < 5:
			spent_attribute_points_poi += 1
			attribute -= 1
			poise += attribute_increase_factor
		elif spent_attribute_points_poi < 10:
			spent_attribute_points_poi += 1
			attribute -= 1
			poise += attribute_increase_factor * 0.5
		elif spent_attribute_points_poi < 15:
			spent_attribute_points_poi += 1
			attribute -= 1
			poise += attribute_increase_factor * 0.2
		elif spent_attribute_points_poi < 20:
			spent_attribute_points_poi += 1
			attribute -= 1
			poise += attribute_increase_factor * 0.1
		elif spent_attribute_points_poi < 25:
			spent_attribute_points_poi += 1
			attribute -= 1
			poise += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_poi += 1
			attribute -= 1
			poise += attribute_increase_factor * 0.01
func _on_MinPoi_pressed():
	if poise > 0.05:
		spent_attribute_points_poi -= 1
		attribute += 1
		if spent_attribute_points_poi < 5:
			poise -= attribute_increase_factor
		elif spent_attribute_points_poi < 10:
			poise -= attribute_increase_factor * 0.5
		elif spent_attribute_points_poi < 15:
			poise -= attribute_increase_factor * 0.2
		elif spent_attribute_points_poi < 20:
			poise -= attribute_increase_factor * 0.1
		elif spent_attribute_points_poi < 25:
			poise -= attribute_increase_factor * 0.05
		else:
			poise -= attribute_increase_factor * 0.01
#Balance
func _on_PlusBal_pressed():
	if attribute > 0:
		if spent_attribute_points_bal < 5:
			spent_attribute_points_bal += 1
			attribute -= 1
			balance += attribute_increase_factor
		elif spent_attribute_points_bal < 10:
			spent_attribute_points_bal += 1
			attribute -= 1
			balance += attribute_increase_factor * 0.5
		elif spent_attribute_points_bal < 15:
			spent_attribute_points_bal += 1
			attribute -= 1
			balance += attribute_increase_factor * 0.2
		elif spent_attribute_points_bal < 20:
			spent_attribute_points_bal += 1
			attribute -= 1
			balance += attribute_increase_factor * 0.1
		elif spent_attribute_points_bal < 25:
			spent_attribute_points_bal += 1
			attribute -= 1
			balance += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_bal += 1
			attribute -= 1
			balance += attribute_increase_factor * 0.01
func _on_MinBal_pressed():
	if balance > 0.05:
		spent_attribute_points_bal -= 1
		attribute += 1
		if spent_attribute_points_bal < 5:
			balance -= attribute_increase_factor
		elif spent_attribute_points_bal < 10:
			balance -= attribute_increase_factor * 0.5
		elif spent_attribute_points_bal < 15:
			balance -= attribute_increase_factor * 0.2
		elif spent_attribute_points_bal < 20:
			balance -= attribute_increase_factor * 0.1
		elif spent_attribute_points_bal < 25:
			balance -= attribute_increase_factor * 0.05
		else:
			balance -= attribute_increase_factor * 0.01
#Charisma 
func _on_PlusCha_pressed():
	if attribute > 0:
		if spent_attribute_points_cha < 5:
			spent_attribute_points_cha += 1
			attribute -= 1
			charisma_multiplier += attribute_increase_factor
		elif spent_attribute_points_cha < 10:
			spent_attribute_points_cha += 1
			attribute -= 1
			charisma_multiplier += attribute_increase_factor * 0.5
		elif spent_attribute_points_cha < 15:
			spent_attribute_points_cha += 1
			attribute -= 1
			charisma_multiplier += attribute_increase_factor * 0.2
		elif spent_attribute_points_cha < 20:
			spent_attribute_points_cha += 1
			attribute -= 1
			charisma_multiplier += attribute_increase_factor * 0.1
		elif spent_attribute_points_cha < 25:
			spent_attribute_points_cha += 1
			attribute -= 1
			charisma_multiplier += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_cha += 1
			attribute -= 1
			charisma_multiplier += attribute_increase_factor * 0.01
func _on_MinCha_pressed():
	if charisma_multiplier > 0.05:
		spent_attribute_points_cha -= 1
		attribute += 1
		if spent_attribute_points_cha < 5:
			charisma_multiplier -= attribute_increase_factor
		elif spent_attribute_points_cha < 10:
			charisma_multiplier -= attribute_increase_factor * 0.5
		elif spent_attribute_points_cha < 15:
			charisma_multiplier -= attribute_increase_factor * 0.2
		elif spent_attribute_points_cha < 20:
			charisma_multiplier -= attribute_increase_factor * 0.1
		elif spent_attribute_points_cha < 25:
			charisma_multiplier -= attribute_increase_factor * 0.05
		else:
			charisma_multiplier -= attribute_increase_factor * 0.01
#Diplomancy 
func _on_PlusDip_pressed():
	if attribute > 0:
		if spent_attribute_points_dip < 5:
			spent_attribute_points_dip += 1
			attribute -= 1
			diplomacy += attribute_increase_factor
		elif spent_attribute_points_dip < 10:
			spent_attribute_points_dip += 1
			attribute -= 1
			diplomacy += attribute_increase_factor * 0.5
		elif spent_attribute_points_dip < 15:
			spent_attribute_points_dip += 1
			attribute -= 1
			diplomacy += attribute_increase_factor * 0.2
		elif spent_attribute_points_dip < 20:
			spent_attribute_points_dip += 1
			attribute -= 1
			diplomacy += attribute_increase_factor * 0.1
		elif spent_attribute_points_dip < 25:
			spent_attribute_points_dip += 1
			attribute -= 1
			diplomacy += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_dip += 1
			attribute -= 1
			diplomacy += attribute_increase_factor * 0.01
func _on_MinDip_pressed():
	if diplomacy > 0.05:
		spent_attribute_points_dip -= 1
		attribute += 1
		if spent_attribute_points_dip < 5:
			diplomacy -= attribute_increase_factor
		elif spent_attribute_points_dip < 10:
			diplomacy -= attribute_increase_factor * 0.5
		elif spent_attribute_points_dip < 15:
			diplomacy -= attribute_increase_factor * 0.2
		elif spent_attribute_points_dip < 20:
			diplomacy -= attribute_increase_factor * 0.1
		elif spent_attribute_points_dip < 25:
			diplomacy -= attribute_increase_factor * 0.05
		else:
			diplomacy -= attribute_increase_factor * 0.01
# Authority
func _on_PlusAut_pressed():
	if attribute > 0:
		if spent_attribute_points_aut < 5:
			spent_attribute_points_aut += 1
			attribute -= 1
			authority += attribute_increase_factor
		elif spent_attribute_points_aut < 10:
			spent_attribute_points_aut += 1
			attribute -= 1
			authority += attribute_increase_factor * 0.5
		elif spent_attribute_points_aut < 15:
			spent_attribute_points_aut += 1
			attribute -= 1
			authority += attribute_increase_factor * 0.2
		elif spent_attribute_points_aut < 20:
			spent_attribute_points_aut += 1
			attribute -= 1
			authority += attribute_increase_factor * 0.1
		elif spent_attribute_points_aut < 25:
			spent_attribute_points_aut += 1
			attribute -= 1
			authority += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_aut += 1
			attribute -= 1
			authority += attribute_increase_factor * 0.01
func _on_MinAut_pressed():
	if authority > 0.05:
		spent_attribute_points_aut -= 1
		attribute += 1
		if spent_attribute_points_aut < 5:
			authority -= attribute_increase_factor
		elif spent_attribute_points_aut < 10:
			authority -= attribute_increase_factor * 0.5
		elif spent_attribute_points_aut < 15:
			authority -= attribute_increase_factor * 0.2
		elif spent_attribute_points_aut < 20:
			authority -= attribute_increase_factor * 0.1
		elif spent_attribute_points_aut < 25:
			authority -= attribute_increase_factor * 0.05
		else:
			authority -= attribute_increase_factor * 0.01
#Courage 
func _on_PlusCou_pressed():
	if attribute > 0:
		if spent_attribute_points_cou < 5:
			spent_attribute_points_cou += 1
			attribute -= 1
			courage += attribute_increase_factor
		elif spent_attribute_points_cou < 10:
			spent_attribute_points_cou += 1
			attribute -= 1
			courage += attribute_increase_factor * 0.5
		elif spent_attribute_points_cou < 15:
			spent_attribute_points_cou += 1
			attribute -= 1
			courage += attribute_increase_factor * 0.2
		elif spent_attribute_points_cou < 20:
			spent_attribute_points_cou += 1
			attribute -= 1
			courage += attribute_increase_factor * 0.1
		elif spent_attribute_points_cou < 25:
			spent_attribute_points_cou += 1
			attribute -= 1
			courage += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_cou += 1
			attribute -= 1
			courage += attribute_increase_factor * 0.01
func _on_MinCou_pressed():
	if courage > 0.05:
		spent_attribute_points_cou -= 1
		attribute += 1
		if spent_attribute_points_cou < 5:
			courage -= attribute_increase_factor
		elif spent_attribute_points_cou < 10:
			courage -= attribute_increase_factor * 0.5
		elif spent_attribute_points_cou < 15:
			courage -= attribute_increase_factor * 0.2
		elif spent_attribute_points_cou < 20:
			courage -= attribute_increase_factor * 0.1
		elif spent_attribute_points_cou < 25:
			courage -= attribute_increase_factor * 0.05
		else:
			courage -= attribute_increase_factor * 0.01
#Loyalty
func _on_PlusLoy_pressed():
	if attribute > 0:
		if spent_attribute_points_loy < 5:
			spent_attribute_points_loy += 1
			attribute -= 1
			loyalty += attribute_increase_factor
		elif spent_attribute_points_loy < 10:
			spent_attribute_points_loy += 1
			attribute -= 1
			loyalty += attribute_increase_factor * 0.5
		elif spent_attribute_points_loy < 15:
			spent_attribute_points_loy += 1
			attribute -= 1
			loyalty += attribute_increase_factor * 0.2
		elif spent_attribute_points_loy < 20:
			spent_attribute_points_loy += 1
			attribute -= 1
			loyalty += attribute_increase_factor * 0.1
		elif spent_attribute_points_loy < 25:
			spent_attribute_points_loy += 1
			attribute -= 1
			loyalty += attribute_increase_factor * 0.05
		else:
			spent_attribute_points_loy += 1
			attribute -= 1
			loyalty += attribute_increase_factor * 0.01
func _on_MinLoy_pressed():
	if loyalty > 0.05:
		spent_attribute_points_loy -= 1
		attribute += 1
		if spent_attribute_points_loy < 5:
			loyalty -= attribute_increase_factor
		elif spent_attribute_points_loy < 10:
			loyalty -= attribute_increase_factor * 0.5
		elif spent_attribute_points_loy < 15:
			loyalty -= attribute_increase_factor * 0.2
		elif spent_attribute_points_loy < 20:
			loyalty -= attribute_increase_factor * 0.1
		elif spent_attribute_points_loy < 25:
			loyalty -= attribute_increase_factor * 0.05
		else:
			loyalty -= attribute_increase_factor * 0.01

func _on_C_pressed():
	$BookStatsSkills.visible = !$BookStatsSkills.visible
	
#Enemy/NPC graphic user interface__________________________________________________________________
onready var enemy_ui = $EnemyUI
onready var en_hp_bar = $EnemyUI/HP
onready var en_en_bar = $EnemyUI/EN
onready var en_re_bar = $EnemyUI/RE
onready var en_hp_label = $EnemyUI/HP/HPlab
onready var en_en_label = $EnemyUI/EN/ENlab
onready var en_re_label = $EnemyUI/RE/RElab
onready var en_stats_label= $EnemyUI/Stats
onready var en_level_label = $EnemyUI/Lvl
onready var cursor = $Camroot/h/v/Camera/Aim
func showEnemyStats():
	if cursor.is_colliding():
		var body = cursor.get_collider()
		if body.is_in_group("Entity") and body != self:
			enemy_ui.visible = true 
			#hp
			en_hp_bar.value = body.health
			en_hp_bar.max_value = body.max_health
			en_hp_label.text = "HP:" + str(round(body.health* 100) / 100) + "/" + str(body.max_health)
			#en
			en_en_bar.value = body.energy
			en_en_bar.max_value = body.max_energy
			en_en_label.text = "EP:" + str(round(body.energy* 100) / 100) + "/" + str(body.max_energy)
			#re
			en_re_bar.value = body.resolve
			en_re_bar.max_value = body.max_resolve
			en_re_label.text = "RE:" + str(round(body.resolve* 100) / 100) + "/" + str(body.max_resolve)
			#stats
			en_stats_label.text = "Defense :" + str(body.defense) +"    "+"Resistance :" + str(body.resistance) +"\nBalance :" + str(body.balance) + "       "+"Impact :" + str(body.impact)
			#level and name
			en_level_label.text = str(body.entity_name) + "  Level: " + str(body.level)
			
		else:
			enemy_ui.visible = false
	else:
		enemy_ui.visible = false
#_______________________________________________Save Data__________________________________________
func savePlayerData():
	var data = {
		"position": translation,
		"direction": direction,
		"unstuck_cd" : unstuck_cd,
#camera stuff
	#	"H_rotation": camera_h.rotation_degrees,
	#	"V_rotation": camera_v.rotation_degrees,
	#	"camera_position": camera.translation,
	#	"camera_rotation": camera.rotation_degrees,  # Save the camera's rotation		
#leveling 
		"attribute": attribute,
		"spent_attribute_points_str": spent_attribute_points_str,
		"spent_attribute_points_fur": spent_attribute_points_fur,
		"spent_attribute_points_imp": spent_attribute_points_imp,
		"spent_attribute_points_fer": spent_attribute_points_fer,
		"spent_attribute_points_res": spent_attribute_points_res,
		
		"spent_attribute_points_ten": spent_attribute_points_ten,
		"spent_attribute_points_acc": spent_attribute_points_acc,
		"spent_attribute_points_dex": spent_attribute_points_dex,
		"spent_attribute_points_poi": spent_attribute_points_poi,
		"spent_attribute_points_bal": spent_attribute_points_bal,
		
		"spent_attribute_points_foc": spent_attribute_points_foc,
		"spent_attribute_points_has": spent_attribute_points_has,
		"spent_attribute_points_agi": spent_attribute_points_agi,
		"spent_attribute_points_cel": spent_attribute_points_cel,
		"spent_attribute_points_fle": spent_attribute_points_fle,
		
		"spent_attribute_points_def": spent_attribute_points_def,
		"spent_attribute_points_end": spent_attribute_points_end,
		"spent_attribute_points_sta": spent_attribute_points_sta,
		"spent_attribute_points_vit": spent_attribute_points_vit,
		"spent_attribute_points_cha": spent_attribute_points_cha,
		
		"spent_attribute_points_loy": spent_attribute_points_loy,
		"spent_attribute_points_dip": spent_attribute_points_dip,
		"spent_attribute_points_aut": spent_attribute_points_aut,
		"spent_attribute_points_cou": spent_attribute_points_cou,
		"spent_attribute_points_int": spent_attribute_points_int,
		
		"spent_attribute_points_wis": spent_attribute_points_wis,
		"spent_attribute_points_san": spent_attribute_points_san,
		"spent_attribute_points_mem": spent_attribute_points_mem,
		"spent_attribute_points_ins": spent_attribute_points_ins,
		"spent_attribute_points_for": spent_attribute_points_for,
#Brain attributes
		"sanity": sanity,
		"wisdom" : wisdom,
		"memory": memory,
		"intelligence": intelligence,
		"instinct": instinct,
#Brute attributes
		"force": force,
		"strength": strength,
		"impact": impact,
		"ferocity": ferocity,
		"fury":fury,
#Precision attributes
		"accuracy": accuracy,
		"dexterity": dexterity,
		"poise": poise,
		"balance": balance,
		"focus": focus,
#Nimble attributes
		"haste": haste,
		"agility": agility,
		"celerity": celerity,
		"flexibility": flexibility,
		"deflection": deflection,
#Toughness attributes
		"endurance": endurance,
		"stamina": stamina,
		"vitality": vitality,
		"recovery": recovery,
		"resistance": resistance,
		"tenacity": tenacity,
#Social attributes 
		"charisma_multiplier":charisma_multiplier,
		"loyalty": loyalty,
		"diplomacy": diplomacy,
		"authority": authority,
		"empathy": empathy,
		"courage": courage,
#crude stats
		"health": health,
		"energy":energy,
		"resolve": resolve,
		"max_health": max_health,
		"max_energy": max_energy,
		"max_resolve": max_resolve,
#hair   
		"hair0":has_hair0,
		"hair1": has_hair1,
		"hair2": has_hair2,
		"hair3": has_hair3,
		"hair4": has_hair4,
		"hair5": has_hair5,
		"hair6": has_hair6,
		"hair7": has_hair7,
		"hair8": has_hair8,
		"hair_color": hair_color,
#eye
		"eye_r_color": eye_r_color,
		"eye_l_color": eye_l_color,
#skin 
		"skin0": skin0,
		"skin1": skin1,
		"skin2": skin2,
		"skin3": skin3,
#height
		"scale_factor": scale_factor,
		"current_height": current_height,
#skills 
		"headstrong_rush_ps": headstrong_rush_ps,
		"pomel_strike_ps": pomel_strike_ps,
#inventory
		"got_weapon": got_weapon,
		"got_sec_weapon": got_sec_weapon,
		"got_shield": got_shield,
		"has_sword0": has_sword0,
		"has_sword1": has_sword1,
		"has_sword2": has_sword2,
		"has_sword3": has_sword3,
		"has_axe2":has_axe2,
		"has_sec_sword0": has_sec_sword0,
		"has_sec_sword1": has_sec_sword1,
		"has_sec_sword2": has_sec_sword2,
		"has_sec_sword3": has_sec_sword3,
		"has_shield0": has_shield0,
#shoulders 
		"got_shoulder": got_shoulder,
		"got_sec_shoulder": got_sec_shoulder,
		"has_shoulder0": has_shoulder0,
		"has_shoulder1": has_shoulder1,
		"has_shoulder2": has_shoulder2,
		"has_sec_shoulder0": has_sec_shoulder0,
		"has_sec_shoulder1": has_sec_shoulder1,
		"has_sec_shoulder2": has_sec_shoulder2,
#earings
		"got_earing": got_earing,
		"got_sec_earing": got_sec_earing,
		"has_earing0": has_earing0,
		"has_earing1": has_earing1,
		"has_earing2": has_earing2,
		"has_sec_earing0": has_sec_earing0,
		"has_sec_earing1": has_sec_earing1,
		"has_sec_earing2": has_sec_earing2,
#bags
		"got_bag": got_bag,
		"has_bag0": has_bag0,
		"has_bag1": has_bag1,
#resources
		"wood": wood,
		"branch":branch,
		"acorn":acorn,
		"resin":resin,
		"acorn_leaf":acorn_leaf,
		"crystal":crystal,
#FaceBlendShapes
		"Smile":Smile,
		"EyesRotation":EyesRotation,
		"EyesInnerClose":EyesInnerClose,
		"EyesMiddleClose":EyesMiddleClose,
		"EyesOuterClose":EyesOuterClose,
		"LipsThickness":LipsThickness,
		"MouthSize":MouthSize,
		"MouthWidth":MouthWidth,
		"ElfEars":ElfEars,
		"EarsPoint":EarsPoint,
		"EyebrowInner":EyebrowInner,
		"EyebrowMiddle":EyebrowMiddle,
		"EyebrowOut":EyebrowOut,
		"CheekBonesHeight":CheekBonesHeight,
		"CheekSize":CheekSize,
		"ChinSize":ChinSize,
		"NoseSize":NoseSize,
		"NoseRotation":NoseRotation,
		"BrowProtrusion":BrowProtrusion,
		"Bimaxillaryprotrusion":Bimaxillaryprotrusion,
		"EarSize":EarSize,
		"EarRotation":EarRotation,
		"has_face0":has_face0,
		"has_face1":has_face1,
		"has_face2":has_face2,
		"has_face3":has_face3,
		"has_face4":has_face4,
#leveling
		"experience": experience,
		"level": level,
		"exp_required": exp_required,
#currency
		"coins": coins
		}

	var dir = Directory.new()
	if !dir.dir_exists(SAVE_DIR):
		dir.make_dir_recursive(SAVE_DIR)
	var file = File.new()
	var error = file.open_encrypted_with_pass(save_path, File.WRITE, "P@paB3ar6969")
	if error == OK:
		file.store_var(data)
		file.close()
func loadPlayerData():
	var file = File.new()
	if file.file_exists(save_path):
		var error = file.open_encrypted_with_pass(save_path, File.READ, "P@paB3ar6969")
		if error == OK:
			var player_data = file.get_var()
			file.close()
			if "position" in player_data:
				translation = player_data["position"]
			if "direction" in player_data:
				direction = player_data["direction"]
			if "unstuck_cd" in player_data:
				unstuck_cd = player_data["unstuck_cd"]
#attributes 
			if "attribute" in player_data:
				attribute = player_data["attribute"]
#brains 
			if "spent_attribute_points_int" in player_data:
				spent_attribute_points_int = player_data["spent_attribute_points_int"]
			if "spent_attribute_points_wis" in player_data:
				spent_attribute_points_wis = player_data["spent_attribute_points_wis"]
			if "spent_attribute_points_ins" in player_data:
				spent_attribute_points_ins = player_data["spent_attribute_points_ins"]
			if "spent_attribute_points_mem" in player_data:
				spent_attribute_points_mem = player_data["spent_attribute_points_mem"]
			if "spent_attribute_points_san" in player_data:
				spent_attribute_points_san = player_data["spent_attribute_points_san"]
#social 
			if "spent_attribute_points_cha" in player_data:
				spent_attribute_points_cha = player_data["spent_attribute_points_cha"]
			if "spent_attribute_points_cou" in player_data:
				spent_attribute_points_cou = player_data["spent_attribute_points_cou"]
			if "spent_attribute_points_loy" in player_data:
				spent_attribute_points_loy = player_data["spent_attribute_points_loy"]
			if "spent_attribute_points_dip" in player_data:
				spent_attribute_points_dip = player_data["spent_attribute_points_dip"]
			if "spent_attribute_points_aut" in player_data:
				spent_attribute_points_aut = player_data["spent_attribute_points_aut"]
#brawns
			if "spent_attribute_points_vit" in player_data:
				spent_attribute_points_vit = player_data["spent_attribute_points_vit"]
			if "spent_attribute_points_res" in player_data:
				spent_attribute_points_res = player_data["spent_attribute_points_res"]
			if "spent_attribute_points_ten" in player_data:
				spent_attribute_points_ten = player_data["spent_attribute_points_ten"]
			if "spent_attribute_points_end" in player_data:
				spent_attribute_points_end = player_data["spent_attribute_points_end"]
			if "spent_attribute_points_sta" in player_data:
				spent_attribute_points_sta = player_data["spent_attribute_points_sta"]
#brute
			if "spent_attribute_points_fur" in player_data:
				spent_attribute_points_fur = player_data["spent_attribute_points_fur"]
			if "spent_attribute_points_for" in player_data:
				spent_attribute_points_for = player_data["spent_attribute_points_for"]
			if "spent_attribute_points_imp" in player_data:
				spent_attribute_points_imp = player_data["spent_attribute_points_imp"]
			if "spent_attribute_points_fer" in player_data:
				spent_attribute_points_fer = player_data["spent_attribute_points_fer"]
			if "spent_attribute_points_str" in player_data:
				spent_attribute_points_str = player_data["spent_attribute_points_str"]
#precision
			if "spent_attribute_points_acc" in player_data:
				spent_attribute_points_acc = player_data["spent_attribute_points_acc"]
			if "spent_attribute_points_dex" in player_data:
				spent_attribute_points_dex = player_data["spent_attribute_points_dex"]
			if "spent_attribute_points_poi" in player_data:
				spent_attribute_points_poi = player_data["spent_attribute_points_poi"]
			if "spent_attribute_points_bal" in player_data:
				spent_attribute_points_bal = player_data["spent_attribute_points_bal"]
			if "spent_attribute_points_foc" in player_data:
				spent_attribute_points_foc = player_data["spent_attribute_points_foc"]
#nimbleness
			if "spent_attribute_points_has" in player_data:
				spent_attribute_points_has = player_data["spent_attribute_points_has"]
			if "spent_attribute_points_agi" in player_data:
				spent_attribute_points_agi = player_data["spent_attribute_points_agi"]
			if "spent_attribute_points_cel" in player_data:
				spent_attribute_points_cel = player_data["spent_attribute_points_cel"]
			if "spent_attribute_points_fle" in player_data:
				spent_attribute_points_fle = player_data["spent_attribute_points_fle"]
			if "spent_attribute_points_def" in player_data:
				spent_attribute_points_def = player_data["spent_attribute_points_def"]


#Brute attributes
			if "force" in player_data:
				force = player_data["force"]
			if "strength" in player_data:
				strength = player_data["strength"]
			if "impact" in player_data:
				impact = player_data["impact"]
			if "ferocity" in player_data:
				ferocity = player_data["ferocity"]
			if "fury" in player_data:
				fury = player_data["fury"]
			if "resistance" in player_data:
				resistance = player_data["resistance"]
			if "tenacity" in player_data:
				tenacity = player_data["tenacity"]
#Brain attributes
			if "sanity" in player_data:
				sanity = player_data["sanity"]
			if "wisdom" in player_data:
				wisdom = player_data["wisdom"]
			if "memory" in player_data:
				memory = player_data["memory"]
			if "intelligence" in player_data:
				intelligence = player_data["intelligence"]
			if "instinct" in player_data:
				instinct = player_data["instinct"]
#Precision attributes
			if "accuracy" in player_data:
				 accuracy = player_data["accuracy"]
			if "dexterity" in player_data:
				dexterity = player_data["dexterity"]
			if "poise" in player_data:
				poise = player_data["poise"]
			if "balance" in player_data:
				balance = player_data["balance"]
			if "focus" in player_data:
				focus  = player_data["focus"]
#Nimble attributes
			if "haste" in player_data:
				haste = player_data["haste"]
			if "agility" in player_data:
				 agility = player_data["agility"]
			if "flexibility" in player_data:
				flexibility = player_data["flexibility"]
			if "celerity" in player_data:
				celerity = player_data["celerity"]
			if "deflection" in player_data:
				deflection = player_data["deflection"]
#Toughness attributes
			if "endurance" in player_data:
				endurance = player_data["endurance"] 
			if "stamina" in player_data:
				stamina = player_data["stamina"]
			if "vitality" in player_data:
				vitality = player_data["vitality"]
			if "recovery" in player_data:
				recovery = player_data["recovery"]
#Social attributes 
			if "charisma_multiplier" in player_data:
				charisma_multiplier = player_data["charisma_multiplier"]
			if "loyalty" in player_data:
				loyalty = player_data["loyalty"]
			if "diplomacy" in player_data:
				diplomacy = player_data["diplomacy"]
			if "authority" in player_data:
				authority = player_data["authority"]
			if "empathy" in player_data:
				empathy = player_data["empathy"]
			if "courage" in player_data:
				courage = player_data["courage"]
#crude stats 				
			if "health" in player_data:
				health = player_data["health"]
			if "max_health" in player_data:
				max_health = player_data["max_health"]
			if "energy" in player_data:
				energy = player_data["energy"]
			if "max_energy" in player_data:
				max_energy = player_data["max_energy"]
			if "resolve" in player_data:
				resolve = player_data["resolve"]
			if "max_resolve" in player_data:
				max_resolve = player_data["max_resolve"]
#skills 
			if "headstrong_rush_ps" in player_data:
				headstrong_rush_ps = player_data["headstrong_rush_ps"]
			if "pomel_strike_ps" in player_data:
				pomel_strike_ps = player_data["pomel_strike_ps"]
#eye
			if "eye_r_color" in player_data:
				eye_r_color = player_data["eye_r_color"]
			if "eye_l_color" in player_data:
				eye_l_color = player_data["eye_l_color"]
#skins      
			if "skin0" in player_data:
				skin0 = player_data["skin0"]
			if "skin1" in player_data:
				skin1 = player_data["skin1"]
			if "skin2" in player_data:
				skin2 = player_data["skin2"]
			if "skin3" in player_data:
				skin3 = player_data["skin3"]
#height
			if "current_height" in player_data:
				current_height = player_data["current_height"]
			if "scale_factor" in player_data:
				scale_factor = player_data["scale_factor"]
#hair 
			if "hair0" in player_data:
				has_hair0 = player_data["hair0"]
			if "hair1" in player_data:
				has_hair1 = player_data["hair1"]
			if "hair2" in player_data:
				has_hair2 = player_data["hair2"]
			if "hair3" in player_data:
				has_hair3 = player_data["hair3"]
			if "hair4" in player_data:
				has_hair4 = player_data["hair4"]
			if "hair5" in player_data:
				has_hair5 = player_data["hair5"]
			if "hair6" in player_data:
				has_hair6 = player_data["hair6"]
			if "hair7" in player_data:
				has_hair7 = player_data["hair7"]
			if "hair8" in player_data:
				has_hair8 = player_data["hair8"]
			if "hair_color" in player_data:
				hair_color = player_data["hair_color"]
#faces
			if "has_face0" in player_data:
				has_face0 = player_data["has_face0"]
			if "has_face1" in player_data:
				has_face1 = player_data["has_face1"]
			if "has_face2" in player_data:
				has_face2 = player_data["has_face2"]
			if "has_face3" in player_data:
				has_face3 = player_data["has_face3"]
			if "has_face4" in player_data:
				has_face4 = player_data["has_face4"]
#inventory 
			if "got_weapon" in player_data:
				got_weapon = player_data["got_weapon"]
			if "got_sec_weapon" in player_data:
				got_sec_weapon = player_data["got_sec_weapon"]
			if "got_shield" in player_data:
				got_shield = player_data["got_shield"]
			if "has_sword0" in player_data:
				has_sword0 = player_data["has_sword0"]
			if "has_sword1" in player_data:
				has_sword1 = player_data["has_sword1"]
			if "has_sword2" in player_data:
				has_sword2 = player_data["has_sword2"]
			if "has_sword3" in player_data:
				has_sword3 = player_data["has_sword3"]
			if "has_axe2" in player_data:
				has_axe2 = player_data["has_axe2"]
			if "has_sec_sword0" in player_data:
				has_sec_sword0 = player_data["has_sec_sword0"]
			if "has_sec_sword1" in player_data:
				has_sec_sword1 = player_data["has_sec_sword1"]
			if "has_sec_sword2" in player_data:
				has_sec_sword2 = player_data["has_sec_sword2"]
			if "has_sec_sword3" in player_data:
				has_sec_sword3 = player_data["has_sec_sword3"]
			if "has_shield0" in player_data:
				has_shield0 = player_data["has_shield0"]
#shoulders 
			if "got_shoulder" in player_data:
				got_shoulder = player_data["got_shoulder"]
			if "got_sec_houlder" in player_data:
				got_sec_shoulder = player_data["got_sec_shoulder"]
			if "has_shoulder0" in player_data:
				has_shoulder0 = player_data["has_shoulder0"]
			if "has_shoulder1" in player_data:
				has_shoulder1 = player_data["has_shoulder1"]
			if "has_shoulder2" in player_data:
				has_shoulder2 = player_data["has_shoulder2"]
				
			if "has_sec_shoulder0" in player_data:
				has_sec_shoulder0 = player_data["has_sec_shoulder0"]
			if "has_sec_shoulder1" in player_data:
				has_sec_shoulder1 = player_data["has_sec_shoulder1"]
			if "has_sec_shoulder2" in player_data:
				has_sec_shoulder2 = player_data["has_sec_shoulder2"]
#earings 
			if "got_earingr" in player_data:
				got_earing = player_data["got_earing"]
			if "got_sec_earing" in player_data:
				got_sec_earing = player_data["got_sec_earing"]
			if "has_earing0" in player_data:
				has_earing0 = player_data["has_earing0"]
			if "has_earing1" in player_data:
				has_earing1 = player_data["has_earing1"]
			if "has_earing2" in player_data:
				has_earing2 = player_data["has_earing2"]
			if "has_sec_earing0" in player_data:
				has_sec_earing0 = player_data["has_sec_earing0"]
			if "has_sec_earing1" in player_data:
				has_sec_earing1 = player_data["has_sec_earing1"]
			if "has_sec_earing2" in player_data:
				has_sec_earing2 = player_data["has_sec_earing2"]
#bags
			if "got_bag" in player_data:
				got_bag = player_data["got_bag"]
			if "has_bag0" in player_data:
				has_bag0 = player_data["has_bag0"]
			if "has_bag1" in player_data:
				has_bag1 = player_data["has_bag1"]
#resources inventory 
			if "wood" in player_data:
				wood = player_data["wood"]
			if "branch" in player_data:
				branch = player_data["branch"]
			if "resin" in player_data:
				resin = player_data["resin"]
			if "acorn" in player_data:
				acorn = player_data["acorn"]
			if "acorn_leaf" in player_data:
				acorn_leaf = player_data["acorn_leaf"]
			if "crystal" in player_data:
				crystal = player_data["crystal"]
#BlendShapes
			if "Smile" in player_data:
				Smile = player_data["Smile"]
			if "EyesRotation" in player_data:
				EyesRotation = player_data["EyesRotation"]
			if "EyesInnerClose" in player_data:
				EyesInnerClose = player_data["EyesInnerClose"]
			if "EyesMiddleClose" in player_data:
				EyesMiddleClose = player_data["EyesMiddleClose"]
			if "EyesOuterClose" in player_data:
				EyesOuterClose = player_data["EyesOuterClose"]
			if "LipsThickness" in player_data:
				LipsThickness = player_data["LipsThickness"]
			if "MouthSize" in player_data:
				MouthSize = player_data["MouthSize"]
			if "MouthWidth" in player_data:
				MouthWidth = player_data["MouthWidth"]
			if "ElfEars" in player_data:
				ElfEars = player_data["ElfEars"]
			if "EarsPoint" in player_data:
				EarsPoint = player_data["EarsPoint"]
			if "EyebrowInner" in player_data:
				EyebrowInner = player_data["EyebrowInner"]
			if "EyebrowMiddle" in player_data:
				EyebrowMiddle = player_data["EyebrowMiddle"]
			if "EyebrowOut" in player_data:
				EyebrowOut = player_data["EyebrowOut"]
			if "CheekBonesHeight" in player_data:
				CheekBonesHeight = player_data["CheekBonesHeight"]
			if "CheekSize" in player_data:
				CheekSize = player_data["CheekSize"]
			if "ChinSize" in player_data:
				ChinSize = player_data["ChinSize"]
			if "NoseSize" in player_data:
				NoseSize = player_data["NoseSize"]
			if "NoseRotation" in player_data:
				NoseRotation = player_data["NoseRotation"]
			if "BrowProtrusion" in player_data:
				BrowProtrusion = player_data["BrowProtrusion"]
			if "Bimaxillaryprotrusion" in player_data:
				Bimaxillaryprotrusion = player_data["Bimaxillaryprotrusion"]
			if "EarSize" in player_data:
				EarSize = player_data["EarSize"]
			if "EarRotation" in player_data:
				EarRotation = player_data["EarRotation"]
#leveling up
			if "experience" in player_data:
				experience = player_data["experience"]
			if "level" in player_data:
				level = player_data["level"]
			if "exp_required" in player_data:
				exp_required = player_data["exp_required"]
#currency	
			if "coins" in player_data:
				coins = player_data["coins"]
func resetSavedData():
	var dir = Directory.new()
	if dir.file_exists(save_path):
		dir.remove(save_path)
		print("Saved data reset")
func _on_SaveDataTimer_timeout():
	savePlayerData()
#___________________________________________HeadStrong Rush UI______________________________
func _on_HeadstrongRush_pressed():
	if headstrong_rush_ps < 5:
		headstrong_rush_ps += 1
		skill_points -= 1		
		if headstrong_rush_ps > 0:
			has_headstrong_rush_skill = true 
	$AllUIHere/Skills/WardenSkills/Set1/HeadstrongRush/SkillLevel.text = str(headstrong_rush_ps)
func _on_HeadstrongRush_mouse_exited():
	for child in get_children():
		if child.is_in_group("Tooltip"):
			child.queue_free()	
#func _on_HeadstrongRush_mouse_entered():
#	var tool_tip_instance = tool_tip.instance()
	#var skill_name = "Headstrong Rush:"
	#var for_text = "Charge a short distance at high speed dealing damage to enemies that you collide with"
#	add_child(tool_tip_instance)
#	tool_tip_instance._make_custom_tooltip(for_text)
	#tool_tip_instance.skillName(skill_name)
#func _on_PomelStrike_mouse_entered():
#	var tool_tip_instance = tool_tip.instance()
#	var skill_name = "Pomel Strike"
#	var for_text = "counter strike with a pome"
#	add_child(tool_tip_instance)
#	tool_tip_instance._make_custom_tooltip(for_text)
#	tool_tip_instance.skillName(skill_name)
#func _on_PomelStrike_mouse_exited():
#	for child in get_children():
#		if child.is_in_group("Tooltip"):
#			child.queue_free()	
#________________________________________Headstrong Rush skill______________________________
func _on_Duration_timeout():
	headstrong_rush_toggle = false
	is_running = false
#func _on_HeadstrongrushCD_timeout():
#	 HeadstrongrushCD.stop()
func _on_PomelStrike_pressed():
	if pomel_strike_ps < 5:
		pomel_strike_ps += 1
		skill_points -= 1		
		if pomel_strike_ps > 0:
			has_pomel_strike_skill = true 
	$AllUIHere/Skills/WardenSkills/Set1/PomelStrike/SkillLevel.text = str(pomel_strike_ps)	
func updateSkills():
	if pomel_strike_ps > 0:
		has_pomel_strike_skill = true 
	if headstrong_rush_ps > 0:
		has_headstrong_rush_skill = true 	
	$AllUIHere/Skills/WardenSkills/Set1/PomelStrike/SkillLevel.text = str(pomel_strike_ps)
	$AllUIHere/Skills/WardenSkills/Set1/HeadstrongRush/SkillLevel.text = str(headstrong_rush_ps)
func _on_MinimapRotation_pressed():
	minimap_rotate = !minimap_rotate
#__________________________________________optimization and performance__________________________________________________________________	
func _on_FPS_pressed():
	var current_fps = Engine.get_target_fps()
	if current_fps == 15:
		Engine.set_target_fps(20)
	elif current_fps == 20:
		Engine.set_target_fps(25)
	elif current_fps == 25:
		Engine.set_target_fps(30)
	elif current_fps == 30:
		Engine.set_target_fps(35)
	elif current_fps == 35:
		Engine.set_target_fps(40)
	elif current_fps == 40:
		Engine.set_target_fps(60)
	elif current_fps == 60:
		Engine.set_target_fps(80)
	elif current_fps == 80:
		Engine.set_target_fps(15)
func updateFPS():
	$Minimap/FPSLabel.text  = "%d" % Engine.get_frames_per_second()
#_____________________________________________Water Detection_____________________________________________________________________________
func _on_WaterDetector_area_entered(area):
	if area.is_in_group("Water"):
		is_swimming = true
func _on_WaterDetector_area_exited(area):
	if area.is_in_group("Water"):
		is_swimming = false
#_______________________________________________________skin editor_______________________________________________________________________

var skin0 = false
var skin1 = false
var skin2 = false
var skin3 = false 

#__________________________________________Unstuck button, teleports the player to world origin when stuck_______________________________
var unstuck_cd = 0
onready var unstuck_label =  $Minimap/UnstuckCDProgressBar/CdLabel
onready var unstuck_button = $Minimap/Unstcuk
onready var unstuck_cd_progress_bar = $Minimap/UnstuckCDProgressBar
func unstuckDisplayCD():	
	unstuck_label.text = str(int(unstuck_cd))
func unstuckVisibility():
	if unstuck_cd == 0:
		unstuck_button.visible = true 
		unstuck_cd_progress_bar.visible = false
	else:
		unstuck_button.visible = false
		unstuck_cd_progress_bar.visible = true
		unstuck_cd_progress_bar.value = ((unstuck_cd/1000.0) * 100.0)
func _on_Unstcuk_pressed():
	if unstuck_cd == 0:
		unstuck_cd = 1000
		translation = Vector3(0, 10, 0)
func _on_OneSecondTimer_timeout():
	unstuck_cd = max(0, unstuck_cd - 900)
	updateFPS()
	debugText()
	roundPositionCoordinates()
	displayClock()
	

#__________________________________________Combat stuff_____________________________________________
func enterCombat():
	if Input.is_action_just_pressed("ui_focus_next"):
		is_in_combat = !is_in_combat
	switchMainFromHipToHand()
	switchSecondaryFromHipToHand()
func switchWeaponStances():
	if attachment_r.get_child_count() > 0:
		if attachment_l.get_child_count() > 0:
			dual_wield_mode = true
			barehanded_mode = false
			one_handed_sword_mode = false
		elif attachment_l.get_child_count() == 0:
			dual_wield_mode = false
			barehanded_mode = false
			one_handed_sword_mode = true 
var lifesteal_pop = preload("res://UI/lifestealandhealing.tscn")
func baseAttack():
	var base_dmg_low = (8 * ((strength * 0.75) + (dexterity * 0.25))) * scale_factor
	var base_dmg_high = (8 * ((strength * 0.75) + (dexterity * 0.25) + (force* 0.15))) * scale_factor
	var text = lifesteal_pop.instance()
	var damage =  rng.randi_range(base_dmg_low,base_dmg_high)
	var aggro_power = damage 
	var enemies = currentInstance.get_node("Hitbox").get_overlapping_bodies() 
	var damage_type = "slash"
	for enemy in enemies:
		if enemy.is_in_group("enemy"):
			if enemy.has_method("takeDamage"):
				if randf() <= critical_chance:
					var critical_damage = damage * critical_strength
					enemy.takeDamage(critical_damage,aggro_power,self,stagger_chance,damage_type)
					health += critical_damage * life_steal
					text.amount =(critical_damage * life_steal)
					pop_up_viewport.add_child(text)
				else:
					enemy.takeDamage(damage,aggro_power,self,stagger_chance,damage_type)
					enemy.takeDamage(damage,aggro_power,self,stagger_chance,"heat")
					health += damage * life_steal
					text.amount =round(damage * life_steal * 100)/ 100
					pop_up_viewport.add_child(text)
	if sec_currentInstance != null:
		var enemies2 = sec_currentInstance.get_node("Hitbox").get_overlapping_bodies() 
		for enemy2 in enemies2:
			if enemy2.has_method("takeDamage"):
				if randf() <= critical_chance:
					var critical_damage = damage * critical_strength
					enemy2.takeDamage(critical_damage,aggro_power,self,stagger_chance,damage_type)
					health += critical_damage * life_steal
					text.amount =round(critical_damage * life_steal * 100)/ 100
					pop_up_viewport.add_child(text)
				else:
					enemy2.takeDamage(damage,aggro_power,self,stagger_chance,damage_type)
					health += damage * life_steal
					pop_up_viewport.add_child(text)
func baseAttackFinish():
	var base_dmg_low = (8 * ((strength * 0.75) + (dexterity * 0.25))) * scale_factor
	var base_dmg_high = (8 * ((strength * 0.75) + (dexterity * 0.25) + (force* 0.15))) * scale_factor
	var text = lifesteal_pop.instance()
	var damage_type = "toxic"
	var damage = rand_range(base_dmg_low *2 ,base_dmg_high *2 )
	var aggro_power = damage 
	var enemies = currentInstance.get_node("Hitbox").get_overlapping_bodies() 
	for enemy in enemies:
		if enemy.is_in_group("enemy"):
			if enemy.has_method("takeDamage"):
				if randf() <= critical_chance:
					var critical_damage = damage * critical_strength
					enemy.takeDamage(critical_damage,aggro_power,self,stagger_chance * 2,damage_type)
					health += critical_damage * life_steal
					text.amount =(critical_damage * life_steal)
					pop_up_viewport.add_child(text)
				else:
					enemy.takeDamage(damage,aggro_power,self,stagger_chance * 2,damage_type)
					health += damage * life_steal
					text.amount =round(damage * life_steal * 100)/ 100
					pop_up_viewport.add_child(text)
	if sec_currentInstance != null:
		var enemies2 = sec_currentInstance.get_node("Hitbox").get_overlapping_bodies() 
		for enemy2 in enemies2:
			if enemy2.has_method("takeDamage"):
				if randf() <= critical_chance:
					var critical_damage = damage * critical_strength
					enemy2.takeDamage(critical_damage,aggro_power,self,stagger_chance * 2, damage_type)
					health += critical_damage * life_steal
					text.amount =round(critical_damage * life_steal * 1000)/ 1000
					pop_up_viewport.add_child(text)
				else:
					enemy2.takeDamage(damage,aggro_power,self,stagger_chance * 2,damage_type)
					health += damage * life_steal
					text.amount =round(damage * life_steal * 1000)/ 1000
func moveAttack(delta):
	if can_move:
		horizontal_velocity = direction * 25 * delta
	else:
		horizontal_velocity = direction * 1 * delta
func moveAttack2(delta):
	if can_move:
		horizontal_velocity = direction * 105 * delta
	else:
		horizontal_velocity = direction * 0.35 * delta
func stopMovement():
	can_move = false
func startMovement():
	can_move = true 
func startStopMove():
	can_move = !can_move
	
onready var arrow = preload("res://weapons/Projectiles/Arrows/1.tscn")
onready var muzle = $Mesh/Muzle
onready var aim = $Camroot/h/v/Camera/Aim
func shoot():
	if Input.is_action_just_pressed("attack"):
		var a = arrow.instance()
		a.instigator = self 
		a.damage = rand_range(82,300)
		a.aggro_power = 30
		muzle.add_child(a)
#__________________________________________________________Weapon Management____________________________________________
#Main Weapon____________________________________________________________________________________________________________
onready var attachment_r = $Mesh/armature/Skeleton/HoldR
onready var attachment_hip = $Mesh/armature/Skeleton/SideL

onready var detector = $Mesh/Detector
var sword0: PackedScene = preload("res://weapons/swords/sword1/sword1.tscn")
var sword1: PackedScene = preload("res://weapons/swords/sword1/sword1.tscn")
var sword2: PackedScene = preload("res://weapons/swords/sword3/sword3.tscn")
var axe2:  PackedScene = preload("res://weapons/axes/axe2.tscn")
var currentInstance: Node = null  
var has_sword0 = false
var has_sword1 = false
var has_sword2 = false
var has_sword3 = false
var has_axe2 = false
var got_weapon = false
var sheet_weapon = false
var is_primary_weapon_on_hip = false
var is_chopping_trees = false

func switchMainFromHipToHand():
	if is_in_combat or is_chopping_trees:
		if attachment_r.get_child_count() == 0:
			if currentInstance != null and currentInstance.get_parent() == attachment_hip:
				# Rotate the weapon before adding it to the hand
				attachment_hip.remove_child(currentInstance)
				attachment_r.add_child(currentInstance)
				is_primary_weapon_on_hip = false
	else:
		if attachment_hip.get_child_count() == 0:
			if currentInstance != null and currentInstance.get_parent() == attachment_r:
				# Rotate the weapon before adding it to the hip
				attachment_r.remove_child(currentInstance)
				attachment_hip.add_child(currentInstance)
				#currentInstance.rotation_degrees = Vector3(-6.9,-2.105,-16)
				#currentInstance.translate(Vector3(0.049,0.019,-0.005))
				is_primary_weapon_on_hip = true
func fixInstance():
	attachment_r.add_child(currentInstance)
	currentInstance.get_node("CollisionShape").disabled = true
	got_weapon = true
func switch():
	if has_sword0:
		if currentInstance == null:
			currentInstance = sword0.instance()
			fixInstance()
	elif has_sword1:    
		if currentInstance == null:
			currentInstance = sword1.instance()
			fixInstance()
	elif has_sword2:    
		if currentInstance == null:
			currentInstance = sword2.instance()
			fixInstance()
	elif has_axe2:
		if currentInstance == null:
			currentInstance = axe2.instance()
			fixInstance()
func drop():
	if currentInstance != null and Input.is_action_just_pressed("drop") and got_weapon:
		attachment_r.remove_child(currentInstance)
		attachment_hip.remove_child(currentInstance)
		# Set the drop position
		var drop_position = global_transform.origin + direction.normalized() * 1.0
		currentInstance.global_transform.origin = Vector3(drop_position.x - rand_range(-0.3, 1), global_transform.origin.y + 0.2, drop_position.z + rand_range(-0.5, 0.88))
		# Set the scale of the dropped instance
		#currentInstance.scale = Vector3(1, 1, 1)
		var collision_shape = currentInstance.get_node("CollisionShape")
		if collision_shape != null:
			collision_shape.disabled = false
		get_tree().root.add_child(currentInstance)
		# Reset variables
		has_sword0 = false
		has_sword1 = false
		has_sword2 = false
		has_axe2 = false
		got_weapon = false
		currentInstance = null
func pickItemsMainHand():
	var bodies = detector.get_overlapping_bodies()
	for body in bodies:
		if Input.is_action_pressed("E"):
			if currentInstance == null:
				if body.is_in_group("sword0") and not got_weapon:
					has_sword0 = true
					got_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("sword1") and not got_weapon:
					has_sword1 = true
					got_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("sword3") and not got_weapon:
					has_sword2 = true
					got_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("axe2") and not got_weapon:
					has_axe2 = true
					got_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
			elif currentInstance != null and sec_currentInstance == null:
				if body.is_in_group("sword0") and not got_sec_weapon:
					has_sec_sword0 = true
					got_sec_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("sword1") and not got_sec_weapon:
					has_sec_sword1 = true
					got_sec_weapon = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("sword3") and not got_sec_weapon:
					has_sec_sword2 = true
					got_sec_weapon = true 
					body.queue_free() 
func MainWeapon():
	pickItemsMainHand()
	switch()
	if Input.is_action_just_pressed("drop"):
		drop()
		has_sword0 = false
		has_sword1 = false
		has_sword2 = false
		has_sword3 = false
		has_axe2 = false
		two_handed_sword_mode = false
		one_handed_sword_mode = false
		sword_and_shield_mode = false 
		bow_mode = false
#Secondary__________________________________________________________________________________________
onready var attachment_l = $Mesh/armature/Skeleton/HoldL
onready var attachment_hip_sec = $Mesh/armature/Skeleton/SideR
var sec_currentInstance: Node = null  
var has_sec_sword0 = false
var has_sec_sword1 = false
var has_sec_sword2 = false
var has_sec_sword3 = false
var got_sec_weapon = false
var is_secondary_weapon_on_hip = false 
func switchSecondaryFromHipToHand():
	if is_in_combat:
		if attachment_l.get_child_count() == 0:
			if sec_currentInstance != null and sec_currentInstance.get_parent() == attachment_hip_sec:
				attachment_hip_sec.remove_child(sec_currentInstance)
				attachment_l.add_child(sec_currentInstance)
				is_secondary_weapon_on_hip = false 
	else:
		if attachment_hip_sec.get_child_count() == 0:
			if sec_currentInstance != null and sec_currentInstance.get_parent() == attachment_l:
				attachment_l.remove_child(sec_currentInstance)
				attachment_hip_sec.add_child(sec_currentInstance)
				is_secondary_weapon_on_hip = true
func fixSecInstance():
	attachment_l.add_child(sec_currentInstance)
	sec_currentInstance.get_node("CollisionShape").disabled = true
	got_sec_weapon = true
func switchSec():
		if has_sec_sword0:
			if sec_currentInstance == null:
				sec_currentInstance = sword0.instance()
				fixSecInstance()
		elif has_sec_sword1:    
			if sec_currentInstance == null:
				sec_currentInstance = sword1.instance()
				fixSecInstance()
		elif has_sec_sword2:    
			if sec_currentInstance == null:
				sec_currentInstance = sword2.instance()
				fixSecInstance()
func dropSec():
	if sec_currentInstance != null and Input.is_action_just_pressed("drop") and got_sec_weapon:
		attachment_l.remove_child(sec_currentInstance)
		attachment_hip_sec.remove_child(sec_currentInstance)
		# Set the drop position
		var drop_position = global_transform.origin + direction.normalized() * 1.0
		sec_currentInstance.global_transform.origin = Vector3(drop_position.x - rand_range(-0.3, 1), global_transform.origin.y + 0.2, drop_position.z + rand_range(-0.5, 0.88))
		# Set the scale of the dropped instance
		#sec_currentInstance.scale = Vector3(1, 1, 1)
		var collision_shape = sec_currentInstance.get_node("CollisionShape")
		if collision_shape != null:
			collision_shape.disabled = false
		get_tree().root.add_child(sec_currentInstance)
		# Reset variables
		has_sec_sword0 = false
		has_sec_sword1 = false
		has_sec_sword2 = false
		got_sec_weapon = false
		sec_currentInstance = null
func SecWeapon():
	switchSec()
	if Input.is_action_just_pressed("drop"):
		dropSec()
		has_sec_sword0 = false
		has_sec_sword1 = false
		has_sec_sword2 = false
#Shield_____________________________________________________________________________________________
onready var attachment_s = $Mesh/armature/Skeleton/HoldL2
var shield0: PackedScene = preload("res://weapons/shields/shield3/shield3.tscn")
var shield_currentInstance: Node = null 
var has_shield0 = false
var got_shield = false
func fixShieldInstance():
	attachment_s.add_child(shield_currentInstance)
	shield_currentInstance.get_node("CollisionShape").disabled = true
	#shield_currentInstance.scale = Vector3(100, 100, 100)
	got_shield = true
func switchShield():
	if has_shield0:
		if shield_currentInstance == null:
			shield_currentInstance = shield0.instance()
			fixShieldInstance()
func pickUpShield():
	var bodies = detector.get_overlapping_bodies()
	for body in bodies:
		if Input.is_action_pressed("E"):
			if shield_currentInstance == null:
				if body.is_in_group("shield3") and not got_shield:
					has_shield0 = true
					got_shield = true
					body.queue_free()
func dropShield():
	if shield_currentInstance != null and Input.is_action_just_pressed("drop"):
		attachment_s.remove_child(shield_currentInstance)
		# Set the drop position
		var drop_position = global_transform.origin + direction.normalized() * 1.0
		shield_currentInstance.global_transform.origin = Vector3(drop_position.x - rand_range(-0.3, 1), global_transform.origin.y + 0.2, drop_position.z + rand_range(-0.5, 0.88))
		# Set the scale of the dropped instance
		#shield_currentInstance.scale = Vector3(1, 1, 1)
		var collision_shape = shield_currentInstance.get_node("CollisionShape")
		if collision_shape != null:
			collision_shape.disabled = false
		get_tree().root.add_child(shield_currentInstance)
		# Reset variables
		has_shield0 = false
		got_shield = false
		shield_currentInstance = null
func ShieldManagement():
	pickUpShield()
	switchShield()
	if Input.is_action_just_pressed("drop"):
		dropShield()
		has_shield0 = false
#Shoulders__________________________________________________________________________________________
onready var shoulder_r = $Mesh/armature/Skeleton/ShoulderR
onready var shoulder_l = $Mesh/armature/Skeleton/ShoulderL

var shoulder0: PackedScene = preload("res://UniversalEquipment/shoulders/1.tscn")
var shoulder1: PackedScene = preload("res://UniversalEquipment/shoulders/2.tscn")
var shoulder2: PackedScene = preload("res://UniversalEquipment/shoulders/3.tscn")
var current_shoulder_instance: Node = null  
var current_sec_shoulder_instance: Node = null  
var has_shoulder0 = false
var has_shoulder1 = false
var has_shoulder2 = false
var has_shoulder3 = false
var got_shoulder = false
#sec
var has_sec_shoulder0 = false
var has_sec_shoulder1 = false
var has_sec_shoulder2 = false
var has_sec_shoulder3 = false
var got_sec_shoulder = false
func fixShoulderInstance():
	shoulder_r.add_child(current_shoulder_instance)
	current_shoulder_instance.get_node("CollisionShape").disabled = true
	current_shoulder_instance.rotation_degrees = Vector3(9.915,-97.862, 107.64)
	current_shoulder_instance.translate(Vector3(0.035, -0.03, 0))
	got_shoulder = true
func fixSecondaryShoulderInstance():
	shoulder_l.add_child(current_sec_shoulder_instance)
	current_sec_shoulder_instance.get_node("CollisionShape").disabled = true
	current_sec_shoulder_instance.rotation_degrees = Vector3(9.915,-97.862, 107.64)
	current_sec_shoulder_instance.translate(Vector3(0.035, -0.03, 0))
	got_sec_shoulder = true
func switchShoulder():
	if has_shoulder0:
		if current_shoulder_instance == null:
			current_shoulder_instance = shoulder0.instance()
			fixShoulderInstance()
	if has_shoulder1:    
		if current_shoulder_instance == null:
			current_shoulder_instance = shoulder1.instance()
			fixShoulderInstance()
	if has_shoulder2:    
		if current_shoulder_instance == null:
			current_shoulder_instance = shoulder2.instance()
			fixShoulderInstance()
func switchSeconadryShoulder():
	if has_sec_shoulder0:
		if current_sec_shoulder_instance == null:
			current_sec_shoulder_instance = shoulder0.instance()
			fixSecondaryShoulderInstance()
	elif has_sec_shoulder1:    
		if current_sec_shoulder_instance == null:
			current_sec_shoulder_instance = shoulder1.instance()
			fixSecondaryShoulderInstance()
	elif has_sec_shoulder2:    
		if current_sec_shoulder_instance == null:
			current_sec_shoulder_instance = shoulder2.instance()
			fixSecondaryShoulderInstance()
func dropShoulder():
	if current_shoulder_instance != null and Input.is_action_just_pressed("drop") and got_shoulder:
		shoulder_r.remove_child(current_shoulder_instance)
		# Set the drop position
		var drop_position = global_transform.origin + direction.normalized() * 1.0
		current_shoulder_instance.global_transform.origin = Vector3(drop_position.x - rand_range(-0.5, 1.25), global_transform.origin.y + 0.2, drop_position.z + rand_range(-0.5, 0.88))
		var collision_shape = current_shoulder_instance.get_node("CollisionShape")
		if collision_shape != null:
			collision_shape.disabled = false
		get_tree().root.add_child(current_shoulder_instance)
		# Reset variables
		has_shoulder0 = false
		has_shoulder1 = false
		has_shoulder2 = false
		got_shoulder = false
		current_shoulder_instance = null
func dropSecondaryShoulder():
	if current_sec_shoulder_instance != null and Input.is_action_just_pressed("drop") and got_sec_shoulder:
		shoulder_l.remove_child(current_sec_shoulder_instance)
		# Set the drop position
		var drop_position = global_transform.origin + direction.normalized() * 1.0
		current_sec_shoulder_instance.global_transform.origin = Vector3(drop_position.x - rand_range(-0.3, 0.95), global_transform.origin.y + 0.2, drop_position.z + rand_range(-0.5, 0.88))
		var collision_shape = current_sec_shoulder_instance.get_node("CollisionShape")
		if collision_shape != null:
			collision_shape.disabled = false
		get_tree().root.add_child(current_sec_shoulder_instance)
		# Reset variables
		has_sec_shoulder0 = false
		has_sec_shoulder1 = false
		has_sec_shoulder2 = false
		got_sec_shoulder = false
		current_sec_shoulder_instance = null
func pickShoulders():
	var bodies = detector.get_overlapping_bodies()
	for body in bodies:
		if Input.is_action_pressed("E"):
			if current_shoulder_instance == null:
				if body.is_in_group("shoulder0") and not got_shoulder:
					has_shoulder0 = true
					got_shoulder = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("shoulder1") and not got_shoulder:
					has_shoulder1 = true
					got_shoulder = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("shoulder3") and not got_shoulder:
					has_shoulder2 = true
					got_shoulder = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
			elif current_shoulder_instance != null and current_sec_shoulder_instance == null:
				if body.is_in_group("shoulder0") and not got_sec_shoulder:
					has_sec_shoulder0 = true
					got_sec_shoulder = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("shoulder1") and not got_sec_shoulder:
					has_sec_shoulder1 = true
					got_sec_shoulder = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("shoulder3") and not got_sec_shoulder:
					has_sec_shoulder2 = true
					got_sec_shoulder = true 
					body.queue_free() 
func pauldronsManagement():
	pickShoulders()
	switchShoulder()
	switchSeconadryShoulder()
	if Input.is_action_just_pressed("drop"):
		dropShoulder()
		dropSecondaryShoulder()
		has_sec_shoulder0 = false
		has_sec_shoulder1 = false
		has_sec_shoulder2 = false
		got_sec_shoulder = false
		has_shoulder0 = false
		has_shoulder1 = false
		has_shoulder2 = false
		got_shoulder = false
#Earings__________________________________________________________________________________________
onready var earing_r = $Mesh/armature/Skeleton/earingR
onready var earing_l = $Mesh/armature/Skeleton/earingL
var earing0: PackedScene = preload("res://UniversalEquipment/Earing/0.tscn")
var earing1: PackedScene = preload("res://UniversalEquipment/Earing/1.tscn")
var earing2: PackedScene = preload("res://UniversalEquipment/Earing/0.tscn")
var current_earing_instance: Node = null  
var current_sec_earing_instance: Node = null  
var has_earing0 = false
var has_earing1 = false
var has_earing2 = false
var has_earing3 = false
var got_earing = false
#sec
var has_sec_earing0 = false
var has_sec_earing1 = false
var has_sec_earing2 = false
var has_sec_earing3 = false
var got_sec_earing = false
func fixEaringInstance():
	earing_r.add_child(current_earing_instance)
	current_earing_instance.get_node("CollisionShape").disabled = true
	current_earing_instance.translate(Vector3(0, 0.033, 0))
	current_earing_instance.scale = Vector3(1, 1, 1)
	got_earing = true
func fixSecondaryEaringInstance():
	earing_l.add_child(current_sec_earing_instance)
	current_sec_earing_instance.get_node("CollisionShape").disabled = true
	current_sec_earing_instance.translate(Vector3(0, 0.033, 0))
	current_sec_earing_instance.scale = Vector3(1, 1, 1)
	got_sec_earing = true
func switchEaring():
	if has_earing0:
		if current_earing_instance == null:
			current_earing_instance = earing0.instance()
			fixEaringInstance()
	if has_earing1:    
		if current_earing_instance == null:
			current_earing_instance = earing1.instance()
			fixEaringInstance()
	if has_earing2:    
		if current_earing_instance == null:
			current_earing_instance = earing2.instance()
			fixEaringInstance()
func switchSeconadryEaring():
	if has_sec_earing0:
		if current_sec_earing_instance == null:
			current_sec_earing_instance = earing0.instance()
			fixSecondaryEaringInstance()
	elif has_sec_earing1:    
		if current_sec_earing_instance == null:
			current_sec_earing_instance = earing1.instance()
			fixSecondaryEaringInstance()
	elif has_sec_earing2:    
		if current_sec_earing_instance == null:
			current_sec_earing_instance = earing2.instance()
			fixSecondaryEaringInstance()
func dropEaring():
	if current_earing_instance != null and Input.is_action_just_pressed("drop") and got_earing:
		earing_r.remove_child(current_earing_instance)
		# Set the drop position
		var drop_position = global_transform.origin + direction.normalized() * 1.0
		current_earing_instance.scale = Vector3(5, 5, 5)
		current_earing_instance.global_transform.origin = Vector3(drop_position.x - rand_range(-0.5, 1.25), global_transform.origin.y + 0.2, drop_position.z + rand_range(-0.5, 0.88))
		var collision_shape = current_earing_instance.get_node("CollisionShape")
		if collision_shape != null:
			collision_shape.disabled = false
		get_tree().root.add_child(current_earing_instance)
		# Reset variables
		has_earing0 = false
		has_earing1 = false
		has_earing2 = false
		got_earing = false
		current_earing_instance = null
func dropSecondaryEaring():
	if current_sec_earing_instance != null and Input.is_action_just_pressed("drop") and got_sec_earing:
		earing_l.remove_child(current_sec_earing_instance)
		# Set the drop position
		var drop_position = global_transform.origin + direction.normalized() * 1.0
		current_sec_earing_instance.scale = Vector3(5, 5, 5)
		current_sec_earing_instance.global_transform.origin = Vector3(drop_position.x - rand_range(-0.3, 0.95), global_transform.origin.y + 0.2, drop_position.z + rand_range(-0.5, 0.88))
		# Set the scale of the dropped instance
		var collision_shape = current_sec_earing_instance.get_node("CollisionShape")
		if collision_shape != null:
			collision_shape.disabled = false
		get_tree().root.add_child(current_sec_earing_instance)
		# Reset variables
		has_sec_earing0 = false
		has_sec_earing1 = false
		has_sec_earing2 = false
		got_sec_earing = false
		current_sec_earing_instance = null
func pickEaring():
	var bodies = detector.get_overlapping_bodies()
	for body in bodies:
		if Input.is_action_pressed("E"):
			if current_earing_instance == null:
				if body.is_in_group("earing0") and not got_earing:
					has_earing0 = true
					got_earing = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("earing1") and not got_earing:
					has_earing1 = true
					got_earing = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("earing2") and not got_earing:
					has_earing2 = true
					got_earing = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
			elif current_earing_instance != null and current_sec_earing_instance == null:
				if body.is_in_group("earing0") and not got_sec_earing:
					has_sec_earing0 = true
					got_sec_earing = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("earing1") and not got_sec_earing:
					has_sec_earing1 = true
					got_sec_earing = true  # Set the flag to prevent picking up multiple items simultaneously
					body.queue_free()  # Remove the picked-up item from the floor
				elif body.is_in_group("earing2") and not got_sec_earing:
					has_sec_earing2 = true
					got_sec_earing = true 
					body.queue_free() 
func earingManagement():
	pickEaring()
	switchEaring()
	switchSeconadryEaring()
	if Input.is_action_just_pressed("drop"):
		dropEaring()
		dropSecondaryEaring()
		has_sec_earing0 = false
		has_sec_earing1 = false
		has_sec_earing2 = false
		got_sec_earing = false
		has_earing0 = false
		has_earing1 = false
		has_earing2 = false
		got_earing = false
#bags_______________________________________________________________________________________________
onready var bag_attachment = $Mesh/armature/Skeleton/bag
var bag0: PackedScene = preload("res://UniversalEquipment/Backpacks/0.tscn")
var bag1: PackedScene = preload("res://UniversalEquipment/Backpacks/1.tscn")
var bag_currentInstance: Node = null 
var has_bag0 = false
var has_bag1 = false
var got_bag = false
func fixBagInstance():
	bag_attachment.add_child(bag_currentInstance)
	bag_currentInstance.get_node("CollisionShape").disabled = true
	bag_currentInstance.rotation_degrees = Vector3(-72.438,170.673,-4.843)

func switchBag():
	if has_bag0:
		if bag_currentInstance == null:
			bag_currentInstance = bag0.instance()
			fixBagInstance()
	elif has_bag1:
		if bag_currentInstance == null:
			bag_currentInstance = bag1.instance()
			fixBagInstance()
func dropBag():
	if bag_currentInstance != null and Input.is_action_just_pressed("drop"):
		bag_attachment.remove_child(bag_currentInstance)
		# Set the drop position
		var drop_position = global_transform.origin + direction.normalized() * 1.0
		bag_currentInstance.global_transform.origin = Vector3(drop_position.x - rand_range(-0.3, 1), global_transform.origin.y + 0.2, drop_position.z + rand_range(-1,1))
		var collision_shape = bag_currentInstance.get_node("CollisionShape")
		if collision_shape != null:
			collision_shape.disabled = false
		get_tree().root.add_child(bag_currentInstance)
		# Reset variables
		has_bag0 = false
		has_bag1 = false
		got_bag = false
		bag_currentInstance = null
func pickUpBag():
	var bodies = detector.get_overlapping_bodies()
	for body in bodies:
		if Input.is_action_pressed("E"):
			if bag_currentInstance == null:
				if body.is_in_group("bag0") and not got_bag:
					has_bag0 = true
					got_bag = true
					body.queue_free()
				elif body.is_in_group("bag1") and not got_bag:
					has_bag1 = true
					got_bag = true
					body.queue_free()
func bagManagement():
	pickUpBag()
	switchBag()
	if Input.is_action_just_pressed("drop"):
		dropBag()
		has_bag0 = false
		has_bag1 = false
		got_bag = false
		
#______________________________________________Character Creator____________________________________
onready var hair_attachment = $Mesh/armature/Skeleton/Hair
var hair0: PackedScene = preload("res://Player/FemaleHuman/hairstyles/0.tscn")
var hair1: PackedScene = preload("res://Player/FemaleHuman/hairstyles/1.tscn")
var hair2: PackedScene = preload("res://Player/FemaleHuman/hairstyles/2.tscn")
var hair3: PackedScene = preload("res://Player/FemaleHuman/hairstyles/3.tscn")
var hair4: PackedScene = preload("res://Player/FemaleHuman/hairstyles/4.tscn")
var hair5: PackedScene = preload("res://Player/FemaleHuman/hairstyles/5.tscn")
var hair6: PackedScene = preload("res://Player/FemaleHuman/hairstyles/6.tscn")
var hair7: PackedScene = preload("res://Player/FemaleHuman/hairstyles/7.tscn")
var hair8: PackedScene = preload("res://Player/FemaleHuman/hairstyles/8.tscn")
var hair_color: Color = Color(1, 1, 1)  # Default color
var current_hair_instance: Node = null
var has_hair0 = false
var has_hair1 = false
var has_hair2 = false
var has_hair3 = false
var has_hair4 = false
var has_hair5 = false
var has_hair6 = false
var has_hair7 = false
var has_hair8 = false
var has_hair9 = false
var has_hair10 = false
var hair_color_change = false
var eyer_color_change = false
var eyel_color_change = false
func switchHair():
	if current_hair_instance:
		current_hair_instance.queue_free() # Remove the current hair instance
	if has_hair0:
		instanceHair0()
	elif has_hair1:
		instanceHair1()
	elif has_hair2:
		instanceHair2()	
	elif has_hair3:
		instanceHair3()
	elif has_hair4:
		instanceHair4()	
	elif has_hair5:
		instanceHair5()
	elif has_hair6:
		instanceHair6()
	elif has_hair7:
		instanceHair7()
	elif has_hair8:
		instanceHair8()
	else:
		instanceHair0()	
func instanceHair0():
	if hair_attachment and hair0:
		var hair_instance = hair0.instance()
		hair_attachment.add_child(hair_instance)
		current_hair_instance = hair_instance
func instanceHair1():
	if hair_attachment and hair1:
		var hair_instance = hair1.instance()
		hair_attachment.add_child(hair_instance)
		current_hair_instance = hair_instance
func instanceHair2():
	if hair_attachment and hair2:
		var hair_instance = hair2.instance()
		hair_attachment.add_child(hair_instance)
		current_hair_instance = hair_instance
func instanceHair3():
	if hair_attachment and hair3:
		var hair_instance = hair3.instance()
		hair_attachment.add_child(hair_instance)
		current_hair_instance = hair_instance
func instanceHair4():
	if hair_attachment and hair4:
		var hair_instance = hair4.instance()
		hair_attachment.add_child(hair_instance)
		current_hair_instance = hair_instance
func instanceHair5():
	if hair_attachment and hair5:
		var hair_instance = hair5.instance()
		hair_attachment.add_child(hair_instance)
		current_hair_instance = hair_instance
func instanceHair6():
	if hair_attachment and hair6:
		var hair_instance = hair6.instance()
		hair_attachment.add_child(hair_instance)
		current_hair_instance = hair_instance
func instanceHair7():
	if hair_attachment and hair7:
		var hair_instance = hair7.instance()
		hair_attachment.add_child(hair_instance)
		current_hair_instance = hair_instance
func instanceHair8():
	if hair_attachment and hair8:
		var hair_instance = hair8.instance()
		hair_attachment.add_child(hair_instance)
		current_hair_instance = hair_instance
func colorhair():
	if current_hair_instance:
		# Get the original material of the hair instance
		var original_material = current_hair_instance.material_override
		# Check if the original material is not null
		if original_material:
			# Duplicate the original material
			var new_material = original_material.duplicate()
			# Assign the new material to the hair instance
			current_hair_instance.material_override = new_material
			# Set the color property of the new material
			new_material.albedo_color = hair_color
func colorEyeR():
	var original_material = eye_r.material_override
	if original_material:
			# Duplicate the original material
			var new_material = original_material.duplicate()
			# Assign the new material to the hair instance
			eye_r.material_override = new_material
			# Set the color property of the new material
			new_material.albedo_color = eye_r_color
func colorEyeL():
	var original_material = eye_l.material_override
	if original_material:
			# Duplicate the original material
			var new_material = original_material.duplicate()
			# Assign the new material to the hair instance
			eye_l.material_override = new_material
			# Set the color property of the new material
			new_material.albedo_color = eye_l_color
func _on_hair0_pressed():
	has_hair0 = true
	has_hair1 = false
	has_hair2 = false	
	has_hair3 = false
	has_hair4 = false
	has_hair5 = false
	has_hair6 = false
	has_hair7 = false
	has_hair8 = false
func _on_hair1_pressed():
	has_hair0 = false
	has_hair1 = true
	has_hair2 = false	
	has_hair3 = false
	has_hair4 = false
	has_hair5 = false
	has_hair6 = false
	has_hair7 = false
	has_hair8 = false
func _on_hair2_pressed():
	has_hair0 = false
	has_hair1 = false
	has_hair2 = true	
	has_hair3 = false
	has_hair4 = false
	has_hair5 = false
	has_hair6 = false
	has_hair7 = false
	has_hair8 = false
func _on_hair3_pressed():
	has_hair0 = false
	has_hair1 = false
	has_hair2 = false	
	has_hair3 = true
	has_hair4 = false
	has_hair5 = false
	has_hair6 = false
	has_hair7 = false
	has_hair8 = false
func _on_hair4_pressed():
	has_hair0 = false
	has_hair1 = false
	has_hair2 = false	
	has_hair3 = false
	has_hair4 = true
	has_hair5 = false
	has_hair6 = false
	has_hair7 = false
	has_hair8 = false
func _on_hair5_pressed():
	has_hair0 = false
	has_hair1 = false
	has_hair2 = false	
	has_hair3 = false
	has_hair4 = false
	has_hair5 = true
	has_hair6 = false
	has_hair7 = false
	has_hair8 = false
func _on_hair6_pressed():
	has_hair0 = false
	has_hair1 = false
	has_hair2 = false	
	has_hair3 = false
	has_hair4 = false
	has_hair5 = false
	has_hair6 = true 
	has_hair7 = false
	has_hair8 = false
func _on_hair7_pressed():
	has_hair0 = false
	has_hair1 = false
	has_hair2 = false	
	has_hair3 = false
	has_hair4 = false
	has_hair5 = false
	has_hair6 = false
	has_hair7 = true
	has_hair8 = false
func _on_hair8_pressed():
	has_hair0 = false
	has_hair1 = false
	has_hair2 = false	
	has_hair3 = false
	has_hair4 = false
	has_hair5 = false
	has_hair6 = false
	has_hair7 = false
	has_hair8 = true
func _on_ColorPicker_color_changed(color):
	colorEyeL()
	colorEyeR()
	if hair_color_change:
		if current_hair_instance:
			# Assuming your hair models have a material with a color property
			var hair_material = current_hair_instance.material_override
			if hair_material:
				# Set the color property of the material
				hair_material.albedo_color = color
				hair_color = color
	if eyer_color_change:
			var eye_r_material = eye_r.material_override
			if eye_r_material:
				# Set the color property of the material
				eye_r_material.albedo_color = color
				eye_r_color = color
	if eyel_color_change:
			var eye_l_material = eye_l.material_override
			if eye_l_material:
				# Set the color property of the material
				eye_l_material.albedo_color = color
				eye_l_color = color
func _on_hair_pressed():
	hair_color_change = !hair_color_change
func _on_EyeL_pressed():
	eyel_color_change = !eyel_color_change
func _on_EyeR_pressed():
	eyer_color_change = !eyer_color_change
onready var eye_r =$Mesh/armature/Skeleton/eyeR/Iris
onready var eye_l = $Mesh/armature/Skeleton/eyeL/Iris
var eye_r_color: Color = Color(1, 1, 1)  # Default eye color
var eye_l_color: Color = Color(1, 1, 1)  # Default eye color
#height editor______________________________________________________________________________________
# Define constants
const base_height = 150 # in centimeters
var CM_TO_FEET_CONVERSION = 0.0328084# 1 cm = 0.0328084 feet
var scale_factor = 1
# Reference to the height label
onready var height_label = $CharacterEditor/SizeEditor/HeightLabel
# Variable to store the current height in centimeters
var current_height = base_height
# Function to update the height label and scale the player
func updateHeightLabel():
	# Display height in centimeters
	var feet = int(current_height * CM_TO_FEET_CONVERSION)
	var inches = int((current_height * CM_TO_FEET_CONVERSION - feet) * 12)
	height_label.text = "Height: " + str(current_height) + " cm" + "    " + str(feet) + " ft " + str(inches) + " in"
	scale = Vector3(scale_factor,scale_factor,scale_factor)
	current_height = base_height * scale_factor
	if current_height == base_height:
		scale_factor = 1 
func _on_MinusHeight_pressed():
	scale_factor -= 0.01
	updateHeightLabel()
func _on_PlusHeight_pressed():
	scale_factor += 0.01
	updateHeightLabel()
#Face blend shapes__________________________________________________________________________________
onready var face = $Mesh/armature/Skeleton/Face/Face
onready var face1 = $Mesh/armature/Skeleton/Face/Face1
onready var face2 = $Mesh/armature/Skeleton/Face/Face2
onready var face3 = $Mesh/armature/Skeleton/Face/Face3
onready var face4 = $Mesh/armature/Skeleton/Face/Face4
var Bimaxillaryprotrusion = 0 #done
var BrowProtrusion = 0 #done
var CheekBonesHeight = 0 #done
var CheekSize = 0 #done
var ChinSize = 0 #done
var EarRotation = 0
var EarSize = 0 #done
var EarsPoint = 0 #done
var ElfEars = 0 #done
var EyebrowInner = 0 # done
var EyebrowMiddle = 0 # done
var EyebrowOut = 0 #done
var EyesInnerClose = 0 # done
var EyesMiddleClose = 0 # done
var EyesOuterClose = 0 # done
var EyesRotation = 0 #done
var LipsThickness = 0 # done
var MouthSize = 0 # done
var MouthWidth = 0 #done
var NoseRotation = 0 #done
var NoseSize = 0 #doen
var Smile = 0 # done

onready var smile_label = $CharacterEditor/FaceEditor/Smile
onready var eye_rot_label = $CharacterEditor/FaceEditor/EyeRot
onready var eye_inner_close_label = $CharacterEditor/FaceEditor/EyeInnerClose
onready var eye_middle_close_label = $CharacterEditor/FaceEditor/EyeMiddleClose
onready var eye_outer_close_label = $CharacterEditor/FaceEditor/EyeOuterClose
onready var lip_thickness_label = $CharacterEditor/FaceEditor/LipThick
onready var mouth_size_label = $CharacterEditor/FaceEditor/MouthSize
onready var mouth_width_label = $CharacterEditor/FaceEditor/MouthWidth
onready var elf_ears_label = $CharacterEditor/FaceEditor/ElfEars
onready var pointy_ears_label = $CharacterEditor/FaceEditor/Pointyears
onready var eyebrow_out_label = $CharacterEditor/FaceEditor/EyebrowOut
onready var eybrow_mid_label = $CharacterEditor/FaceEditor/EyebrowMid
onready var eybrow_inn_label = $CharacterEditor/FaceEditor/EyebrowInn
onready var cheekbones_label = $CharacterEditor/FaceEditor/Cheekbones
onready var cheek_size_label = $CharacterEditor/FaceEditor/CheekSize
onready var chin_size_label = $CharacterEditor/FaceEditor/ChinSize
onready var nose_size_label = $CharacterEditor/FaceEditor/NoseSize
onready var nose_rotation_label = $CharacterEditor/FaceEditor/NoseRot
onready var brow_label = $CharacterEditor/FaceEditor/BrowProtrusion
onready var teet_prot_label = $CharacterEditor/FaceEditor/TeethProtrusion
onready var ear_size_label = $CharacterEditor/FaceEditor/EarSize
onready var ear_rot_label = $CharacterEditor/FaceEditor/EarRot
func faceBlendShapes():
	smileBlendShape()
	eyeRotationBlendShape()
	eyeInnerCloseBlendShape()
	eyeMiddleCloseBlendShape()
	eyeOuterCloseBlendShape()
	lipThichnessBlendShape()
	mouthSizeBlendShape()
	mouthWidthBlendShape()
	elfEarsBlendShape()
	pointyEarsBlendShape()
	eyebrowOutBlendShape()
	eyebrowInnBlendShape()
	eyebrowMidBlendShape()
	cheekBonesBlendShape()
	cheekSizeBlendShape()
	chinSizeBlendShape()
	noseSizeBlendShape()
	noseRotBlendShape()
	browProtBlendShape()
	bimaxillaryprotrusionBlendShape()
	earSizeBlendShape()
	earRotBlendShape()
func smileBlendShape():
	smile_label.text =  str(Smile)
	face.set("blend_shapes/Smile",Smile)
	face2.set("blend_shapes/Smile",Smile)
	if Input.is_action_pressed("smilePlus"):
		if Smile <1.5:
			Smile += 0.002
			if Smile >1.5:
				Smile = 1.5
	elif Input.is_action_pressed("smileMinus"):
		if Smile >-1.5:
			Smile -= 0.002
			if Smile <-1.5: 
				Smile = -1.5
func eyeRotationBlendShape():
	eye_rot_label.text = str(EyesRotation)
	face.set("blend_shapes/EyesRotation",EyesRotation)
	face2.set("blend_shapes/EyesRotation",EyesRotation)
	if Input.is_action_pressed("eyeRotUp"):
		if EyesRotation <1.5:
			EyesRotation += 0.002
			if EyesRotation >1.5: 
				EyesRotation = 1.5
	elif Input.is_action_pressed("eyeRotDown"):
		if EyesRotation >-1.5:
			EyesRotation -= 0.002
			if EyesRotation <-1.5: 
				EyesRotation = -1.5	
func eyeInnerCloseBlendShape():
	eye_inner_close_label.text = str(EyesInnerClose)
	face.set("blend_shapes/EyesInnerClose",EyesInnerClose)
	face2.set("blend_shapes/EyesInnerClose",EyesInnerClose)
	if Input.is_action_pressed("eyeInnerClosePlus"):
		if EyesInnerClose  <1.5:
			EyesInnerClose  += 0.002
			if EyesInnerClose  >1.5: 
				EyesInnerClose  = 1.5
	elif Input.is_action_pressed("eyeInnerCloseMinus"):
		if EyesInnerClose  >-1.5:
			EyesInnerClose  -= 0.002
			if EyesInnerClose  <-1.5: 
				EyesInnerClose  = -1.5
func eyeMiddleCloseBlendShape():
	eye_middle_close_label.text = str(EyesMiddleClose)
	face.set("blend_shapes/EyesMiddleClose",EyesMiddleClose)
	face2.set("blend_shapes/EyesMiddleClose",EyesMiddleClose)
	if Input.is_action_pressed("eyeMiddleClosePlus"):
		if EyesMiddleClose  <1.5:
			EyesMiddleClose  += 0.002
			if EyesMiddleClose  >1.5: 
				EyesMiddleClose  = 1.5
	elif Input.is_action_pressed("eyeMiddleCloseMinus"):
		if EyesMiddleClose  >-1.5:
			EyesMiddleClose  -= 0.002
			if EyesMiddleClose  <-1.5: 
				EyesMiddleClose  = -1.5
func eyeOuterCloseBlendShape():
	eye_outer_close_label.text = str(EyesOuterClose)
	face.set("blend_shapes/EyeOuterClose",EyesOuterClose)
	face1.set("blend_shapes/EyeOuterClose",EyesOuterClose)
	face2.set("blend_shapes/EyeOuterClose",EyesOuterClose)
	face3.set("blend_shapes/EyeOuterClose",EyesOuterClose)
	face4.set("blend_shapes/EyeOuterClose",EyesOuterClose)
	if Input.is_action_pressed("eyeOuterClosePlus"):
		if EyesOuterClose  <1.5:
			EyesOuterClose  += 0.002
			if EyesOuterClose  >1.5: 
				EyesOuterClose  = 1.5
	elif Input.is_action_pressed("eyeOuterCloseMinus"):
		if EyesOuterClose  >-1.5:
			EyesOuterClose  -= 0.002
			if EyesOuterClose  <-1.5: 
				EyesOuterClose  = -1.5
func lipThichnessBlendShape():
	lip_thickness_label.text = str(LipsThickness)
	face.set("blend_shapes/LipsThickness",LipsThickness)
	face1.set("blend_shapes/LipsThickness",LipsThickness)
	face2.set("blend_shapes/LipsThickness",LipsThickness)
	face3.set("blend_shapes/LipsThickness",LipsThickness)
	face4.set("blend_shapes/LipsThickness",LipsThickness)
	if Input.is_action_pressed("lipThicknessPlus"):
		if LipsThickness  <2.5:
			LipsThickness  += 0.01
			if LipsThickness  >2.5: 
				LipsThickness  = 2.5
	elif Input.is_action_pressed("lipThicknessMinus"):
		if LipsThickness  >-2.5:
			LipsThickness  -= 0.01
			LipsThickness  = -2.5
func mouthSizeBlendShape():
	mouth_size_label.text = str(MouthSize)
	face.set("blend_shapes/MouthSize",MouthSize)
	face1.set("blend_shapes/MouthSize",MouthSize)
	face2.set("blend_shapes/MouthSize",MouthSize)
	face3.set("blend_shapes/MouthSize",MouthSize)
	face4.set("blend_shapes/MouthSize",MouthSize)
	if Input.is_action_pressed("mouthSizePlus"):
		if MouthSize  <1.5:
			MouthSize  += 0.01
			if MouthSize  >1.5: 
				MouthSize  = 1.5
	elif Input.is_action_pressed("mouthSizeMinus"):
		if MouthSize >-1.5:
			MouthSize  -= 0.01
			if MouthSize  <-1.5: 
				MouthSize  = -1.5
func mouthWidthBlendShape():
	mouth_width_label.text = str(MouthWidth)
	face.set("blend_shapes/MouthWidth",MouthWidth)
	face1.set("blend_shapes/MouthWidth",MouthWidth)
	face2.set("blend_shapes/MouthWidth",MouthWidth)
	face3.set("blend_shapes/MouthWidth",MouthWidth)
	face4.set("blend_shapes/MouthWidth",MouthWidth)
	if Input.is_action_pressed("mouthWidthPlus"):
		if MouthWidth  <1.5:
			MouthWidth  += 0.01
			if MouthWidth  >1.5: 
				MouthWidth  = 1.5
	elif Input.is_action_pressed("mouthWidthMinus"):
		if MouthWidth >-1.5:
			MouthWidth -= 0.01
			if MouthWidth  <-1.5: 
				MouthWidth  = -1.5
func elfEarsBlendShape():
	elf_ears_label.text = str(ElfEars)
	face.set("blend_shapes/ElfEars",ElfEars)
	face1.set("blend_shapes/ElfEars",ElfEars)
	face2.set("blend_shapes/ElfEars",ElfEars)
	face3.set("blend_shapes/ElfEars",ElfEars)
	face4.set("blend_shapes/ElfEars",ElfEars)
	if Input.is_action_pressed("elfPlus"):
		if ElfEars  <2.5:
			ElfEars  += 0.01
			if ElfEars  >2.5: 
				ElfEars  = 2.5
	elif Input.is_action_pressed("elfMinus"):
		if ElfEars >-0.5:
			ElfEars -= 0.01
			if ElfEars  <-0.5: 
				ElfEars  = -0.5
func pointyEarsBlendShape():
	pointy_ears_label.text = str(EarsPoint)
	face.set("blend_shapes/EarsPoint",EarsPoint)
	face1.set("blend_shapes/EarsPoint",EarsPoint)
	face2.set("blend_shapes/EarsPoint",EarsPoint)
	face3.set("blend_shapes/EarsPoint",EarsPoint)
	face4.set("blend_shapes/EarsPoint",EarsPoint)
	if Input.is_action_pressed("pointyEarsPlus"):
		if EarsPoint  <2.5:
			EarsPoint  += 0.01
			if EarsPoint  >2.5: 
				EarsPoint  = 2.5
	elif Input.is_action_pressed("pointyEarsMinus"):
		if EarsPoint >-0.5:
			EarsPoint -= 0.01
			if EarsPoint  <-0.5: 
				EarsPoint  = -0.5
func eyebrowOutBlendShape():
	eyebrow_out_label.text = str(EyebrowOut)
	face.set("blend_shapes/EyebrowOut",EyebrowOut)
	face1.set("blend_shapes/EyebrowOut",EyebrowOut)
	face2.set("blend_shapes/EyebrowOut",EyebrowOut)
	face3.set("blend_shapes/EyebrowOut",EyebrowOut)
	face4.set("blend_shapes/EyebrowOut",EyebrowOut)
	if Input.is_action_pressed("eyebrowOutPlus"):
		if EyebrowOut  <2.5:
			EyebrowOut += 0.025
			if EyebrowOut  >2.5: 
				EyebrowOut  = 2.5
	elif Input.is_action_pressed("eyebrowOutMinus"):
		if EyebrowOut >-1.5:
			EyebrowOut -= 0.025
			if EyebrowOut  <-1.5: 
				EyebrowOut  = -1.5
func eyebrowMidBlendShape():
	eybrow_mid_label.text = str(EyebrowMiddle)
	face.set("blend_shapes/EyebrowMiddle",EyebrowMiddle)
	face1.set("blend_shapes/EyebrowMiddle",EyebrowMiddle)
	face2.set("blend_shapes/EyebrowMiddle",EyebrowMiddle)
	face3.set("blend_shapes/EyebrowMiddle",EyebrowMiddle)
	face4.set("blend_shapes/EyebrowMiddle",EyebrowMiddle)
	if Input.is_action_pressed("eyebrowMidPlus"):
		if EyebrowMiddle  <2.5:
			EyebrowMiddle += 0.025
			if EyebrowMiddle  >2.5: 
				EyebrowMiddle  = 2.5
	elif Input.is_action_pressed("eyebrowMidMinus"):
		if EyebrowMiddle >-1.5:
			EyebrowMiddle -= 0.025
			if EyebrowMiddle  <-1.5: 
				EyebrowMiddle  = -1.5
func eyebrowInnBlendShape():
	eybrow_inn_label.text = str(EyebrowInner)
	face.set("blend_shapes/EyebrowInner",EyebrowInner)
	face1.set("blend_shapes/EyebrowInner",EyebrowInner)
	face2.set("blend_shapes/EyebrowInner",EyebrowInner)
	face3.set("blend_shapes/EyebrowInner",EyebrowInner)
	face4.set("blend_shapes/EyebrowInner",EyebrowInner)
	if Input.is_action_pressed("eyebrowInnerPlus"):
		if EyebrowInner  <2.5:
			EyebrowInner += 0.025
			if EyebrowInner  >2.5: 
				EyebrowInner  = 2.5
	elif Input.is_action_pressed("eyebrowInnerMinus"):
		if EyebrowInner >-1.5:
			EyebrowInner -= 0.025
			if EyebrowInner  <-1.5: 
				EyebrowInner  = -1.5
func cheekBonesBlendShape():
	cheekbones_label.text = str(CheekBonesHeight)
	face.set("blend_shapes/CheekBonesHeight",CheekBonesHeight)
	face1.set("blend_shapes/CheekBonesHeight",CheekBonesHeight)
	face2.set("blend_shapes/CheekBonesHeight",CheekBonesHeight)
	face3.set("blend_shapes/CheekBonesHeight",CheekBonesHeight)
	face4.set("blend_shapes/CheekBonesHeight",CheekBonesHeight)
	if Input.is_action_pressed("cheekbonesPlus"):
		if CheekBonesHeight  <1.5:
			CheekBonesHeight += 0.025
			if CheekBonesHeight >1.5:
				CheekBonesHeight = 1.5
	elif Input.is_action_pressed("cheekbonesMinus"):
		if CheekBonesHeight >-0.5:
			CheekBonesHeight -= 0.025
			if CheekBonesHeight  <-0.5: 
				CheekBonesHeight  = -0.5
func cheekSizeBlendShape():
	cheek_size_label.text = str(CheekSize)
	face.set("blend_shapes/CheekSize",CheekSize)
	face1.set("blend_shapes/CheekSize",CheekSize)
	face2.set("blend_shapes/CheekSize",CheekSize)
	face3.set("blend_shapes/CheekSize",CheekSize)
	face4.set("blend_shapes/CheekSize",CheekSize)
	if Input.is_action_pressed("cheekSizePlus"):
		if CheekSize  <1.5:
			CheekSize += 0.025
			if CheekSize >1.5:
				CheekSize = 1.5
	elif Input.is_action_pressed("cheekSizeMinus"):
		if CheekSize >-0.5:
			CheekSize -= 0.025
			if CheekSize <-0.5: 
				CheekSize = -0.5
func chinSizeBlendShape():
	chin_size_label.text = str(ChinSize)
	face.set("blend_shapes/ChinSize",ChinSize)
	face1.set("blend_shapes/ChinSize",ChinSize)
	face2.set("blend_shapes/ChinSize",ChinSize)
	face3.set("blend_shapes/ChinSize",ChinSize)
	face4.set("blend_shapes/ChinSize",ChinSize)
	if Input.is_action_pressed("chinSizePlus"):
		if ChinSize <1.5:
			ChinSize += 0.025
			if ChinSize >1.5:
				ChinSize = 1.5
	elif Input.is_action_pressed("chinSizeMinus"):
			ChinSize -= 0.025
			if ChinSize <-0.5: 
				ChinSize = -0.5
func noseSizeBlendShape():
	nose_size_label.text = str(NoseSize)
	face.set("blend_shapes/NoseSize",NoseSize)
	face1.set("blend_shapes/NoseSize",NoseSize)
	face2.set("blend_shapes/NoseSize",NoseSize)
	face3.set("blend_shapes/NoseSize",NoseSize)
	face4.set("blend_shapes/NoseSize",NoseSize)
	if Input.is_action_pressed("noseSizePlus"):
		if NoseSize <1.5:
			NoseSize += 0.025
			if NoseSize >1.5:
				NoseSize = 1.5
	elif Input.is_action_pressed("noseSizeMinus"):
			NoseSize -= 0.025
			if NoseSize <-0.5: 
				NoseSize = -0.5
func noseRotBlendShape():
	nose_rotation_label.text = str(NoseRotation)
	face.set("blend_shapes/NoseRotation",NoseRotation)
	face1.set("blend_shapes/NoseRotation",NoseRotation)
	face2.set("blend_shapes/NoseRotation",NoseRotation)
	face3.set("blend_shapes/NoseRotation",NoseRotation)
	face4.set("blend_shapes/NoseRotation",NoseRotation)
	if Input.is_action_pressed("noseRotPlus"):
			NoseRotation += 0.025
			if NoseRotation >2.5:
				NoseRotation = 2.5
	elif Input.is_action_pressed("noseRotMinus"):
			NoseRotation -= 0.025
			if NoseRotation <-2.5: 
				NoseRotation = -2.5
func browProtBlendShape():
	brow_label.text = str(BrowProtrusion)
	face.set("blend_shapes/BrowProtrusion",BrowProtrusion)
	face1.set("blend_shapes/BrowProtrusion",BrowProtrusion)
	face2.set("blend_shapes/BrowProtrusion",BrowProtrusion)
	face3.set("blend_shapes/BrowProtrusion",BrowProtrusion)
	face4.set("blend_shapes/BrowProtrusion",BrowProtrusion)
	if Input.is_action_pressed("browProtrusionPlus"):
			BrowProtrusion += 0.025
			if BrowProtrusion >2.5:
				BrowProtrusion = 2.5
	elif Input.is_action_pressed("browProtrusionMinus"):
			BrowProtrusion -= 0.025
			if BrowProtrusion <-0: 
				BrowProtrusion = 0
func bimaxillaryprotrusionBlendShape():
	teet_prot_label.text = str(Bimaxillaryprotrusion)
	face.set("blend_shapes/Bimaxillaryprotrusion",Bimaxillaryprotrusion)
	face1.set("blend_shapes/Bimaxillaryprotrusion",Bimaxillaryprotrusion)
	face2.set("blend_shapes/Bimaxillaryprotrusion",Bimaxillaryprotrusion)
	face3.set("blend_shapes/Bimaxillaryprotrusion",Bimaxillaryprotrusion)
	face4.set("blend_shapes/Bimaxillaryprotrusion",Bimaxillaryprotrusion)
	if Input.is_action_pressed("teethProtrusionPlus"):
			Bimaxillaryprotrusion += 0.025
			if Bimaxillaryprotrusion >2.5:
				Bimaxillaryprotrusion = 2.5
	elif Input.is_action_pressed("teethProtrusionMinus"):
			Bimaxillaryprotrusion -= 0.025
			if Bimaxillaryprotrusion <-2.5: 
				Bimaxillaryprotrusion = -2.5
func earSizeBlendShape():
	ear_size_label.text = str(EarSize)
	face.set("blend_shapes/EarSize",EarSize)
	face1.set("blend_shapes/EarSize",EarSize)
	face2.set("blend_shapes/EarSize",EarSize)
	face3.set("blend_shapes/EarSize",EarSize)
	face4.set("blend_shapes/EarSize",EarSize)
	if Input.is_action_pressed("earSizePlus"):
			EarSize += 0.025
			if EarSize >2.5:
				EarSize = 2.5
	elif Input.is_action_pressed("earSizeMinus"):
			EarSize -= 0.025
			if EarSize <-2.5: 
				EarSize = -2.5
func earRotBlendShape():
	ear_rot_label.text = str(EarRotation)
	face.set("blend_shapes/EarRotation",EarRotation)
	face1.set("blend_shapes/EarRotation",EarRotation)
	face2.set("blend_shapes/EarRotation",EarRotation)
	face3.set("blend_shapes/EarRotation",EarRotation)
	face4.set("blend_shapes/EarRotation",EarRotation)
	if Input.is_action_pressed("earRotUp"):
			EarRotation += 0.015
			if EarRotation >1:
				EarRotation = 1
	elif Input.is_action_pressed("earRotDown"):
			EarRotation -= 0.015
			if EarRotation <-1: 
				EarRotation = -1
func _on_10FPSCharacterEditor_timeout():
	faceBlendShapes()
	switchHair()
	colorhair()
	switchFaces()
func _on_Edit_pressed():
	$CharacterEditor.visible = !$CharacterEditor.visible
	if $CharacterEditor.visible:
		$"10FPSCharacterEditor".start()
	else:
		$"10FPSCharacterEditor".stop()
func _on_ResetFace_pressed():
	Bimaxillaryprotrusion = 0
	BrowProtrusion = 0
	CheekBonesHeight = 0 
	CheekSize = 0 
	ChinSize = 0
	EarRotation = 0
	EarSize = 0
	EarsPoint = 0 
	ElfEars = 0 
	EyebrowInner = 0 
	EyebrowMiddle = 0 
	EyebrowOut = 0 
	EyesInnerClose = 0 
	EyesMiddleClose = 0 
	EyesOuterClose = 0 
	EyesRotation = 0 
	LipsThickness = 0 
	MouthSize = 0 
	MouthWidth = 0 
	NoseRotation = 0
	NoseSize = 0
	Smile = 0 
func _on_Random_pressed():
	Bimaxillaryprotrusion = round(rand_range(-0.3, 0.15) * 1000) / 1000
	#BrowProtrusion = round(rand_range(-0.3, 0.3) * 1000) / 1000
	CheekBonesHeight = round(rand_range(-0.3, 0.7) * 1000) / 1000
	CheekSize = round(rand_range(-0.3, 0.3) * 1000) / 1000
	ChinSize = round(rand_range(-0.3, 0.25) * 1000) / 1000
	EarRotation = round(rand_range(-0.3, 1) * 1000) / 1000
	EarSize = round(rand_range(-0.3, 1) * 1000) / 1000
	EarsPoint = round(rand_range(-0.3, 1) * 1000) / 1000
	ElfEars = round(rand_range(-0.3, 1) * 1000) / 1000
	EyebrowInner = round(rand_range(-0.3, 1) * 1000) / 1000
	EyebrowMiddle = round(rand_range(-0.3, 1) * 1000) / 1000
	EyebrowOut = round(rand_range(-0.3, 1) * 1000) / 1000
	EyesInnerClose = round(rand_range(-0.3, 1) * 1000) / 1000
	EyesMiddleClose = round(rand_range(-0.3, 1) * 1000) / 1000
	EyesOuterClose = round(rand_range(-0.3, 1) * 1000) / 1000
	EyesRotation = round(rand_range(-0.3, 1) * 1000) / 1000
	LipsThickness = round(rand_range(-2.5, 1) * 1000) / 1000
	MouthSize = round(rand_range(-0.7, 1) * 1000) / 1000
	MouthWidth = round(rand_range(-1, 0.5) * 1000) / 1000
	NoseRotation = round(rand_range(-0.1, 1) * 1000) / 1000
	NoseSize = round(rand_range(-0.75, 0.5) * 1000) / 1000
	Smile = round(rand_range(-1, 1) * 1000) / 1000
var has_face0 = true
var has_face1 = false
var has_face2 = false
var has_face3 = false
var has_face4 = false
func _on_Face0_pressed():
	has_face0 = true
	has_face1 = false
	has_face2 = false
	has_face3 = false
	has_face4 = false
func _on_Face1_pressed():
	has_face0 = false
	has_face1 = true
	has_face2 = false
	has_face3 = false
	has_face4 = false
func _on_Face2_pressed():
	has_face0 = false
	has_face1 = false
	has_face2 = true
	has_face3 = false
	has_face4 = false
func _on_Face3_pressed():
	has_face0 = false
	has_face1 = false
	has_face2 = false
	has_face3 = true
	has_face4 = false
func _on_Face4_pressed():
	has_face0 = false
	has_face1 = false
	has_face2 = false
	has_face3 = false
	has_face4 = true
func switchFaces():
	if has_face0:
		face.visible = true
		face1.visible = false
		face2.visible = false
		face3.visible = false
		face4.visible = false
	elif has_face1:
		face.visible = false
		face1.visible = true
		face2.visible = false
		face3.visible = false
		face4.visible = false
	elif has_face2:
		face.visible = false
		face1.visible = false
		face2.visible = true
		face3.visible = false
		face4.visible = false
	elif has_face3:
		face.visible = false
		face1.visible = false
		face2.visible = false
		face3.visible = true
		face4.visible = false
	elif has_face4:
		face.visible = false
		face1.visible = false
		face2.visible = false
		face3.visible = false
		face4.visible = true
#mobile controls____________________________________________________________________________________
var mobileControlsInstance = null
# Mobile controls button pressed
func _on_MobileControls_pressed():
	# Check if mobile controls are already instanced
	if mobileControlsInstance != null:
		# If they are, remove them
		mobileControlsInstance.queue_free()
		mobileControlsInstance = null
	else:
		# If not, instance and add them
		var mobile_controls = load("res://Player/MobileControls.tscn")
		mobileControlsInstance = mobile_controls.instance()
		add_child(mobileControlsInstance)
#_____________________________________Resource Gathering____________________________________________
var chopping_power = 1
var chopping_efficiency = 1 
var wood = 0 
var branch = 0 
var acorn = 0 
var resin = 0
var acorn_leaf = 0 
var loot_amount = 1
var crystal = 0
onready var resources_label = $Resources
onready var pop_up_viewport = $Mesh/TakeDamageView/Viewport
var pop_up_resource = preload("res://UI/floatingResource.tscn")
func ChopTree():
	var trees = currentInstance.get_node("Hitbox").get_overlapping_bodies()
	for tree in trees:
		if tree.is_in_group("tree"):
			tree.health -= chopping_power
			print(str(tree.health))
			var loot = pop_up_resource.instance()
			var loot_wood_only = pop_up_resource.instance()
			# Generate a random number between 0 and 1
			var random_value = randf()
			loot_wood_only.amount = 1 
			loot_wood_only.wood = true 
			loot_wood_only.off1 += 25
			loot_wood_only.off2 += 25
			wood += 1 
			pop_up_viewport.add_child(loot_wood_only)
			# 25% chance for wood
			if random_value < 0.2:
				loot.wood = true
				loot_amount = rng.randi_range(1, 2)
				wood += loot_amount * chopping_efficiency
				loot.amount = round(loot_amount * chopping_efficiency * 1) / 1
			# 25% chance for acorn
			elif random_value < 0.4:
				loot.acorn = true
				loot_amount = rng.randi_range(5, 45)
				acorn += loot_amount * chopping_efficiency
				loot.amount = round(loot_amount * chopping_efficiency * 1) / 1
			# 25% chance for branch
			elif random_value < 0.6:
				loot.branch = true
				loot_amount = rng.randi_range(3, 5)
				branch += loot_amount * chopping_efficiency
				loot.amount = round(loot_amount * chopping_efficiency * 1) / 1
			elif random_value < 0.8:
				loot.acorn_leaf = true
				loot_amount = rng.randi_range(15, 25)
				acorn_leaf += loot_amount * chopping_efficiency
				loot.amount = round(loot_amount * chopping_efficiency * 1) / 1
			# 25% chance for resin
			else:
				loot.resin = true
				loot_amount = rng.randi_range(1, 5)
				resin += loot_amount * chopping_efficiency
				loot.amount = round(loot_amount * chopping_efficiency * 1) / 1
			pop_up_viewport.add_child(loot)
			# Update the UI label to show the amounts of wood, acorn, branch, and resin
			resources_label.text = "Wood: " + str(wood) + "\nAcorn: " + str(acorn) + "\nBranch: " + str(branch) + "\nResin: " + str(resin)+ "\nLeaf: " + str(acorn_leaf)
		elif tree.is_in_group("crystal"):
			tree.health -= chopping_power
			print(str(tree.health))
			var loot = pop_up_resource.instance()
			var loot_wood_only = pop_up_resource.instance()
			# Generate a random number between 0 and 1
			var random_value = randf()
			loot.amount = 1
			crystal += 1
			loot.crystal = true 
			pop_up_viewport.add_child(loot)
			# Update the UI label to show the amounts of wood, acorn, branch, and resin
			resources_label.text = "Wood: " + str(wood) + "\nAcorn: " + str(acorn) + "\nBranch: " + str(branch) + "\nResin: " + str(resin)+ "\nLeaf: " + str(acorn_leaf)+ "\nCrystal: " + str(crystal)
#__________________________________________Leveling_________________________________________________
var experience = 0
var level = 0
var exp_required = 150
onready var level_progress_bar = $BookStatsSkills/LevelUPBar

func levelUP():
	updateProgressBar()
	# Check if the player has gained enough EXP to level up
	while experience >= exp_required:
		experience -= exp_required
		level += 1
		attribute += 1  # Assuming you have an 'attribute' variable to represent the gained attribute
		# Adjust the experience curve (customize this formula as needed)
		exp_required = int(150 * 1.2 * level)
		print("Level UP! New Level: " + str(level))
		print("Remaining EXP for Next Level: " + str(exp_required - experience))
		# Update the progress bar with the current EXP progress
var experience_multiplier = 0
onready var experience_multipli_val =  $BookStatsSkills/CombatStats/OutOfCombatStats/BonusEXPValue
func updateExpMult():
	experience_multiplier = (intelligence * 0.25) + (wisdom * 0.25) + (memory * 0.25) + (instinct * 0.25)
	experience_multipli_val.text = "x" + str(experience_multiplier)
func receiveExperience(amount):
	updateExpMult()
	experience += amount * experience_multiplier
		
func updateProgressBar():
	level_progress_bar.value = experience
	level_progress_bar.max_value = exp_required
#_____________________________________Currency______________________________________________________
onready var money_label = $Money
var coins = 0 
func money():
	# Calculate the number of titanium, platinum, gold, silver, and copper coins
	var eternium_coins = max(0, coins / 1000000000000)  # 1 titanium = 1000 platinum = 1000000 gold = 1000000000 silver = 1000000000000 coins
	var rhodium_coins = max(0, (coins % 1000000000000) / 1000000000)  # 1 platinum = 1000 gold = 1000000 silver = 1000000000 coins
	var gold_coins = max(0, (coins % 1000000000) / 1000000)  # 1 gold = 1000 silver = 1000000 coins
	var silver_coins = max(0, (coins % 1000000) / 1000)  # 1 silver = 1000 coins
	var copper_coins = max(0, coins % 1000)
	# Construct the text to display in the label
	var label_text = "eternium coins: " + str(eternium_coins) + "\n" + "rhodium coins: " + str(rhodium_coins) + "\n" + "gold coins: " + str(gold_coins) + "\n" + "silver coins: " + str(silver_coins) + "\n" + "copper coins: " + str(copper_coins)
	# Update the money_label text
	money_label.text = label_text
